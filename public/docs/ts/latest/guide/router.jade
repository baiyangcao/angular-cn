include ../_util-fns

:marked
  The Angular **`Router`** enables navigation from one [view](./glossary.html#view) to the next
  as users perform application tasks.

  在用户使用应用程序时，Angular的***路由器***能让用户从一个[视图](./glossary.html#view)导航到另一个视图。

  This guide covers the router's primary features, illustrating them through the evolution
  of a small application that you can <live-example>run live in the browser</live-example>.

  本章覆盖了该路由器的主要特性。我们通过一个小型应用的成长演进来讲解它。参见<live-example>在线例子</live-example>。

include ../../../_includes/_see-addr-bar

.l-main-section

:marked
  ## Overview
  
  ## 概览

  The browser is a familiar model of application navigation:
  
  浏览器具有我们熟悉的导航模式：

  * Enter a URL in the address bar and the browser navigates to a corresponding page.
  
      在地址栏输入URL，浏览器就会导航到相应的页面。
      
  * Click links on the page and the browser navigates to a new page.
  
      在页面中点击链接，浏览器就会导航到一个新页面。
      
  * Click the browser's back and forward buttons and the browser navigates
    backward and forward through the history of pages you've seen.
    
      点击浏览器的前进和后退按钮，浏览器就会在你的浏览历史中向前或向后导航。

  The Angular `Router` ("the router") borrows from this model.
  It can interpret a browser URL as an instruction to navigate to a client-generated view.
  It can pass optional parameters along to the supporting view component that help it decide what specific content to present.
  You can bind the router to links on a page and it will navigate to
  the appropriate application view when the user clicks a link.
  You can navigate imperatively when the user clicks a button, selects from a drop box,
  or in response to some other stimulus from any source. And the router logs activity
  in the browser's history journal so the back and forward buttons work as well.
  
  Angular的`Router`（即“路由器”）借鉴了这个模型。它把浏览器中的URL看做一个操作指南，
    据此导航到一个由客户端生成的视图，并可以把参数传给支撑视图的相应组件，帮它决定具体该展现哪些内容。
    我们可以为页面中的链接绑定一个路由，这样，当用户点击链接时，就会导航到应用中相应的视图。
    当用户点击按钮、从下拉框中选取，或响应来自任何地方的事件时，我们也可以在代码控制下进行导航。
    路由器还在浏览器的历史日志中记录下这些活动，这样浏览器的前进和后退按钮也能照常工作。

:marked
  # Contents
  
  # 目录

  * [The Basics](#basics)

    [基础知识](#basics)


    * [`<base href>`](#basics-base-href)

      [`<base href>`](#basics-base-href)

    * [Router imports](#basics-router-imports)

      [导入路由库](#basics-router-imports)

    * [Configuration](#basics-config)

      [配置](#basics-config)

    * [Router outlet](#basics-router-outlet)

      [路由插座](#basics-router-outlet)

    * [Router links](#basics-router-links)

      [路由链接](#basics-router-links)

    * [Router state](#basics-router-state)

      [路由状态](#basics-router-state)

    * [Summary](#basics-summary)

      [小结](#basics-summary)


  * [The sample application](#sample-app-intro)

    [范例应用](#sample-app-intro)


  * [Milestone 1: Getting started with the router](#getting-started)

    [里程碑1：开始使用路由器](#getting-started)


    * [Setting the base href](#base-href)

      [设置基地址（base href）](#base-href)

    * [Importing from the router library](#import)

      [从路由库导入](#import)

    * [Define routes](#route-config)

      [定义路由](#route-config)

    * [The `AppComponent` shell](#shell)

      [`AppComponent`壳](#shell)

    * [RouterOutlet](#router-outlet)

      [RouterOutlet](#router-outlet)

    * [`RouterLink binding`](#router-link)

      [`RouterLink`绑定](#router-link)

    * [`RouterLinkActive` binding](#router-link-active)

      [`RouterLinkActive`绑定](#router-link-active)

    * [Wildcard route](#wildcard)

      [通配符路由](#wildcard)

    * [The default route to heroes](#default-route)

      [把默认路由设置为英雄管理路由](#default-route)


  * [Milestone 2: Routing module](#routing-module)

    [里程碑2：路由模块](#routing-module)


    * [Refactor the routing configuration into a routing module](#routing-refactor)

      [把路由配置重构到路由模块中](#routing-refactor)

    * [Do you need a Routing Module?](#why-routing-module)

      [我们需要路由模块吗？](#why-routing-module)


  * [Milestone 3: Heroes feature](#heroes-feature)

    [里程碑3：英雄管理特性区](#heroes-feature)


    * [Add heroes functionality](#heroes-functionality)

      [添加英雄管理功能](#heroes-functionality)

    * [Hero feature routing requirements](#hero-routing-requirements)

      [英雄管理特性区的路由需求](#hero-routing-requirements)

    * [Hero feature route configuration](#hero-routing-module)

      [英雄管理特性区的路由配置](#hero-routing-module)

    * [Add the routing module to the _HeroesModule_](#adding-routing-module)

      [把路由模块添加到_HeroesModule_中](#adding-routing-module)

    * [Remove duplicate hero routes](#remove-duplicate-hero-routes)

      [移除重复的英雄管理路由](#remove-duplicate-hero-routes)

    * [Import hero module into AppModule](#merge-hero-routes)

      [把英雄管理模块导入AppModule中](#merge-hero-routes)

    * [Module import order matters](#routing-module-order)

      [要注意模块导入的顺序](#routing-module-order)

    * [Route Definition with a parameter](#route-def-with-parameter)

      [带参数的路由定义](#route-def-with-parameter)

    * [Navigate to hero detail imperatively](#navigate)

      [强制导航到路由详情](#navigate)

    * [Setting the route parameters in the list view](#route-parameters)

      [在列表视图中设置路由参数](#route-parameters)

    * [ActivatedRoute: the one-stop-shop for route information](#activated-route)

      [ActivatedRoute：一站式获取路由信息](#activated-route)

    * [Observable params and component reuse](#reuse)

      [监听参数变化与组件复用](#reuse)

    * [Snapshot: the _no-observable_ alternative](#snapshot)

      [Snapshot：*不需要Observable*的备选方案](#snapshot)

    * [Navigating back to the list component](#nav-to-list)

      [导航回列表组件](#nav-to-list)

    * [Route Parameters: Required or optional?](#optional-route-parameters)

      [路由参数：必要还是可选？](#optional-route-parameters)

    * [Heroes list: optionally selecting a hero](#optionally-selecting)

      [英雄列表：可选的当前英雄](#optionally-selecting)

    * [Route parameters in the *ActivatedRoute* service](#route-parameters-activated-route)

      [在*ActivatedRoute*服务中的路由参数](#route-parameters-activated-route)

    * [Adding animations to the routed component](#route-animation)

      [为路由组件添加动画](#route-animation)

    * [Milestone 3 wrap up](#milestone-3-wrap-up)

      [里程碑3总结](#milestone-3-wrap-up)


  * [Milestone 4: Crisis center feature](#milestone-4)

    [里程碑4：危机中心特性区](#milestone-4)


    * [A crisis center with child routes](#crisis-child-routes)

      [带子路由的英雄中心](#crisis-child-routes)

    * [Child routing component](#child-routing-component)

      [子路由组件](#child-routing-component)

    * [Child route configuration](#child-route-config)

      [子路由配置](#child-route-config)

    * [Import crisis center module into the _AppModule_ routes](#import-crisis-module)

      [把危机中心模块导入到*AppModule*路由中](#import-crisis-module)

    * [Relative navigation](#relative-navigation)

      [相对导航](#relative-navigation)

    * [Navigate to crisis detail with a relative URL](#nav-to-crisis)

      [使用相对URL导航到危机详情](#nav-to-crisis)

    * [Displaying multiple routes in named outlets](#named-outlets)

      [使用命名插座（outlet）同时显示多个路由](#named-outlets)

    * [Secondary routes](#secondary-routes)

      [第二路由](#secondary-routes)

    * [Add a secondary route](#add-secondary-route)

      [添加第二路由](#add-secondary-route)

    * [Secondary route navigation: merging routes during navigation](#secondary-route-navigation)

      [第二路由导航：在导航期间合并路由](#secondary-route-navigation)

    * [Clearing secondary routes](#clear-secondary-routes)

      [清理第二路由](#clear-secondary-routes)


  * [Milestone 5: Route guards](#guards)

    [里程碑5：路由守卫](#guards)


    * [`CanActivate`: requiring authentication](#can-activate-guard)

      [`CanActivate`：需要认证](#can-activate-guard)

    * [Component-less route: grouping routes without a component](#component-less-route)

      [无组件路由：不借助组件对路由进行分组](#component-less-route)

    * [Guard the admin feature](#guard-admin-feature)

      [守卫管理特性区](#guard-admin-feature)

    * [Teach *AuthGuard* to authenticate](#teach-auth)

      [教*AuthGuard*进行认证](#teach-auth)

    * [Add the login component](#add-login-component)

      [添加登录组件](#add-login-component)

    * [`CanActivateChild`: guarding child routes](#can-activate-child-guard)

      [`CanActivateChild`：保护子路由](#can-activate-child-guard)

    * [`CanDeactivate`: handling unsaved changes](#can-deactivate-guard)

      [`CanDeactivate`：处理未保存的更改](#can-deactivate-guard)

    * [Cancel and save](#cancel-save)

      [取消与保存](#cancel-save)

    * [`Resolve`: pre-fetching component data](#resolve-guard)

      [`Resolve`：预先获取组件数据](#resolve-guard)

    * [Fetch data before navigating](#fetch-before-navigating )

      [在导航之前获取数据](#fetch-before-navigating )

    * [Query parameters and fragments](#query-parameters)

      [查询参数与URL片段](#query-parameters)


  * [Milestone 6: Asynchronous routing](#asynchronous-routing)

    [里程碑6：异步路由](#asynchronous-routing)


    * [Lazy loading route configuration](#lazy-loading-route-config)

      [惰性加载路由配置](#lazy-loading-route-config)

    * [CanLoad Guard: guarding unauthorized loading of feature modules](#can-load-guard)

      [CanLoad守卫：保护未认证的特性模块，控制是否加载](#can-load-guard)

    * [Preloading: background loading of feature areas](#preloading)

      [预加载：后台加载特性区](#preloading)

    * [How preloading works](#how-preloading)

      [预加载工作原理](#how-preloading)

    * [Lazy load the crisis center](#lazy-load-crisis-center)

      [惰性加载危机中心特性区](#lazy-load-crisis-center)

    * [_CanLoad_ blocks preload](#preload-canload)

      [用_CanLoad_组织预加载](#preload-canload)

    * [Custom Preloading Strategy](#custom-preloading)

      [自定义预加载策略](#custom-preloading)

    * [Inspect the router's configuration](#inspect-config)

      [审查路由器的配置](#inspect-config)

    * [Wrap up and final app](#final-app)

      [总结与最终版应用](#final-app)


  * [Appendices](#appendices)

    [附录](#appendices)


    * [Appendix: link parameters array](#link-parameters-array)

      [附录：链接参数数组](#link-parameters-array)

    * [Appendix: *LocationStrategy* and browser URL styles](#location-strategy)

      [附录：*LocationStrategy*和浏览器URL风格](#location-strategy)


.l-main-section
  
a#basics
:marked
  ## The Basics
  
  ## 基础知识

  This guide proceeds in phases, marked by milestones, starting from a simple two-pager
  and building toward a modular, multi-view design with child routes.

  An introduction to a few core router concepts will help orient you to the details that follow.

a#basics-base-href
:marked
  ### *&lt;base href>*
  
  Most routing applications should add a `<base>` element to the `index.html` as the first child in the  `<head>` tag
  to tell the router how to compose navigation URLs.

  大多数带路由的应用都要在**`index.html`**的`<head>`标签下先添加一个`<base>`元素，来告诉路由器该如何合成导航用的URL。

  If the `app` folder is the application root, as it is for the sample application,
  set the `href` value *exactly* as shown here.

  如果`app`文件夹是该应用的根目录（就像我们的范例应用一样），那就把`href`的值设置为下面这样：

+makeExcerpt('src/index.html', 'base-href')

a#basics-router-imports
:marked
  ### Router imports

  ### 从路由库中导入

  The Angular Router is an optional service that presents a particular component view for a given URL.
  It is not part of the Angular core. It is in its own library package, `@angular/router`.
  Import what you need from it as you would from any other Angular package.

  Angular的路由器是一个可选的服务，它用来呈现指定的URL所对应的视图。
  它并不是Angular核心库的一部分，而是在它自己的`@angular/router`包中。
  像其它Angular包一样，我们可以从它导入所需的一切。

+makeExcerpt('src/app/app.module.1.ts (import)', 'import-router')

.l-sub-section

  :marked
    You'll learn about more options in the [details below](#browser-url-styles).

    我们将会在[后面](#browser-url-styles)详细讲解其它选项。

a#basics-config
:marked
  ### Configuration

  A routed Angular application has one singleton instance of the *`Router`* service. 
  When the browser's URL changes, that router looks for a corresponding `Route`
  from which it can determine the component to display.

  A router has no routes until you configure it.
  The following example creates four route definitions, configures the router via the `RouterModule.forRoot` method,
  and adds the result to the `AppModule`'s `imports` array.

+makeExcerpt('src/app/app.module.0.ts (excerpt)', '')

a#example-config
:marked
  The `appRoutes` array of *routes* describes how to navigate.
  Pass it to the `RouterModule.forRoot` method in the module `imports` to configure the router.

  Each `Route` maps a URL `path` to a component.
  There are _no leading slashes_ in the _path_. 
  The router parses and builds the final URL for you,
  allowing you to use both relative and absolute paths when navigating between application views.

  The `:id` in the first route is a token for a route parameter. In a URL such as `/hero/42`, "42"
  is the value of the `id` parameter. The corresponding `HeroDetailComponent`
  will use that value to find and present the hero whose `id` is 42.
  You'll learn more about route parameters later in this guide.

  第一个路由中的`:id`是一个路由参数的令牌(Token)。比如`/hero/42`这个URL中，“42”就是`id`参数的值。
  此URL对应的`HeroDetailComponent`组件将据此查找和展现`id`为42的英雄。
  在本章中稍后的部分，我们将会学习关于路由参数的更多知识。


  The `data` property in the third route is a place to store arbitrary data associated with
  this specific route. The data property is accessible within each activated route. Use it to store 
  items such as page titles, breadcrumb text, and other read-only, _static_ data. 
  You'll use the [resolve guard](#resolve-guard) to retrieve _dynamic_ data later in the guide.

  第三个路由中的`data`属性用来存放于每个具体路由有关的任意信息。该数据可以被任何一个激活路由访问，并能用来保存诸如
  页标题、面包屑以及其它静态只读数据。本章稍后的部分，我们将使用[resolve守卫](#resolve-guard)来获取动态数据。

  The `empty path` in the fourth route represents the default path for the application,
  the place to go when the path in the URL is empty, as it typically is at the start.
  This default route redirects to the route for the `/heroes` URL and, therefore, will display the `HeroesListComponent`.

  The `**` path in the last route is a **wildcard**. The router will select this route
  if the requested URL doesn't match any paths for routes defined earlier in the configuration. 
  This is useful for displaying a "404 - Not Found" page or redirecting to another route.

  **The order of the routes in the configuration matters** and this is by design. The router uses a **first-match wins**
  strategy when matching routes, so more specific routes should be placed above less specific routes. 
  In the configuration above, routes with a static path are listed first, followed by an empty path route,
  that matches the default route. 
  The wildcard route comes last because it matches _every URL_ and should be selected _only_ if no other routes are matched first.

  **这些路由的定义顺序**是故意如此设计的。路由器使用**先匹配者优先**的策略来匹配路由，所以，具体路由应该放在通用路由的前面。在上面的配置中，带静态路径的路由被放在了前面，后面是空路径路由，因此它会作为默认路由。而通配符路由被放在最后面，这是因为它能匹配上*每一个URL*，因此应该**只有在**前面找不到其它能匹配的路由时才匹配它。

a#basics-router-outlet
:marked
  ### Router outlet

  ### 路由插座

  Given this configuration, when the browser URL for this application becomes `/heroes`,
  the router matches that URL to the route path `/heroes` and displays the `HeroListComponent`
  _after_ a `RouterOutlet` that you've placed in the host view's HTML.
  
  有了这份配置，当本应用在浏览器中的URL变为`/heroes`时，路由器就会匹配到`path`为`heroes`的`Route`，并在宿主视图中的*`RouterOutlet`*之后显示`HeroListComponent`组件。
  
code-example(language="html").
  &lt;router-outlet>&lt;/router-outlet>
  &lt;!-- Routed views go here -->

a#basics-router-links
:marked
  ### Router links


  ### 路由器链接

  Now you have routes configured and a place to render them, but
  how do you navigate? The URL could arrive directly from the browser address bar.
  But most of the time you navigate as a result of some user action such as the click of
  an anchor tag.

  现在，我们已经有了配置好的一些路由，还找到了渲染它们的地方，但又该如何导航到它呢？固然，从浏览器的地址栏直接输入URL也能做到，但是大多数情况下，导航是某些用户操作的结果，比如点击一个A标签。

  Consider the following template:

+makeExcerpt('src/app/app.component.1.ts', 'template', '')
:marked
  The `RouterLink` directives on the anchor tags give the router control over those elements. 
  The navigation paths are fixed, so you can assign a string to the `routerLink` (a "one-time" binding).

  Had the navigation path been more dynamic, you could have bound to a template expression that
  returned an array of route link parameters (the _link parameters array_). 
  The router resolves that array into a complete URL.

  The **`RouterLinkActive`** directive on each anchor tag helps visually distinguish the anchor for the currently selected "active" route.
  The router adds the `active` CSS class to the element when the associated *RouterLink* becomes active. 
  You can add this directive to the anchor or to its parent element.

a#basics-router-state
:marked
  ### Router state

  ### 路由器状态

  After the end of each successful navigation lifecycle, the router builds a tree of `ActivatedRoute` objects
  that make up the current state of the router. You can access the current `RouterState` from anywhere in the
  application using the `Router` service and the `routerState` property.

  在导航时的每个生命周期成功完成时，路由器会构建出一个`ActivatedRoute`组成的树，它表示路由器的当前状态。
  我们可以在应用中的任何地方用`Router`服务及其`routerState`属性来访问当前的`RouterState`值。

  Each `ActivatedRoute` in the `RouterState` provides methods to traverse up and down the route tree
  to get information from parent, child and sibling routes.

  路由器状态为我们提供了从任意激活路由开始向上或向下遍历路由树的一种方式，以获得关于父、子、兄弟路由的信息。

a#basics-summary
:marked
  ### Summary

  ### 总结一下

  The application has a configured router.
  The shell component has a `RouterOutlet` where it can display views produced by the router.
  It has `RouterLink`s that users can click to navigate via the router.

  该应用有一个配置过的路由器。
  外壳组件中有一个`RouterOutlet`，它能显示路由器所生成的视图。
  它还有一些`RouterLink`，用户可以点击它们，来通过路由器进行导航。

  Here are the key `Router` terms and their meanings:

  下面是一些*路由器*中的关键词汇及其含义：

style td, th {vertical-align: top}
table
  tr
    th
      p Router Part
      p 路由器部件
    th
      p Meaning
      p 含义
  tr
    td
      p <code>Router</code>
      p <code>Router</code>（路由器）
    td
      p.
        Displays the application component for the active URL.
        Manages navigation from one component to the next.
      p 为激活的URL显示应用组件。管理从一个组件到另一个组件的导航
  tr
    td
      p <code>RouterModule</code>
      p <code>RouterModule</code>（路由器模块）
    td
      p.
        A separate Angular module that provides the necessary service providers
        and directives for navigating through application views.
      p 一个独立的Angular模块，用于提供所需的服务提供商，以及用来在应用视图之间进行导航的指令。
  tr
    td
      p <code>Routes</code>
      p <code>Routes</code>（路由数组）
    td
      p.
        Defines an array of Routes, each mapping a URL path to a component.
      p 定义了一个路由数组，每一个都会把一个URL路径映射到一个组件。
  tr
    td
      p <code>Route</code>
      p <code>Route</code>（路由）
    td
      p.
        Defines how the router should navigate to a component based on a URL pattern.
        Most routes consist of a path and a component type.
      p 定义路由器该如何根据URL模式（pattern）来导航到组件。大多数路由都由路径和组件类构成。
  tr
    td
      p <code>RouterOutlet</code>
      p <code>RouterOutlet</code>（路由插座）
    td
      p.
        The directive (<code>&lt;router-outlet></code>) that marks where the router displays a view.
      p 该指令（<code>&lt;router-outlet></code>）用来标记出路由器该在哪里显示视图。
  tr
    td
      p <code>RouterLink</code>
      p <code>RouterLink</code>（路由链接）
    td
      p.
        The directive for binding a clickable HTML element to
        a route. Clicking an element with a <code>routerLink</code> directive
        that is bound to a <i>link parameters array</i> triggers a navigation.
      p.
        该指令用来把一个可点击的HTML元素绑定到路由。
        点击带有绑定到<i>字符串</i>或<i>链接参数数组</i>的<code>routerLink</code>指令的元素就会触发一次导航。
  tr
    td
      p <code>RouterLinkActive</code>
      p <code>RouterLinkActive</code>（活动路由链接）
    td
      p.
        The directive for adding/removing classes from an HTML element when an associated
        <code>routerLink</code> contained on or inside the element becomes active/inactive.
      p.
        当HTML元素上或元素内的routerLink变为激活或非激活状态时，该指令为这个HTML元素添加或移除CSS类。
  tr
    td
      p <code>ActivatedRoute</code>
      p <code>ActivatedRoute</code>（激活的路由）
    td
      p.
        A service that is provided to each route component that contains route specific
        information such as route parameters, static data, resolve data, global query params, and the global fragment.
      p 为每个路由组件提供提供的一个服务，它包含特定于路由的信息，比如路由参数、静态数据、解析数据、全局查询参数和全局碎片（fragment）。
  tr
    td
      p <code>RouterState</code>
      p <code>RouterState</code>（路由器状态）
    td
      p.
        The current state of the router including a tree of the currently activated
        routes together with convenience methods for traversing the route tree.
      p 路由器的当前状态包含了一棵由程序中激活的路由构成的树。它包含一些用于遍历路由树的快捷方法。
  tr
    tdp <b><i>Link parameters array</i></b>
    p <code><i>链接参数数组</i></code>td
      p.
        An array that the router interprets as a routing instruction.
        You can bind that array toa <code>RouterLink</code>  or pass the array as an argument to
        the <code>Router.navigate</code> method.
      p 这个数组会被路由器解释成一个路由操作指南。我们可以把一个<code>RouterLink</code>绑定到该数组，或者把它作为参数传给<code>Router.navigate</code>方法。
  tr
    td
      p <b><i>Routing component</i></b>
      p <b><i>路由组件</i></b>
    td
      p An Angular component with a <code>RouterOutlet</code> that displays views based on router navigations.
      p 一个带有<code>RouterOutlet</code>的Angular组件，它根据路由器的导航来显示相应的视图。

.l-main-section

a#sample-app-intro
:marked
  ## The sample application

  ## 范例应用
  
  This guide describes development of a multi-page routed sample application.
  Along the way, it highlights design decisions and describes key features of the router such as:

  * Organizing the application features into modules.
  * Navigating to a component (*Heroes* link to "Heroes List").
  * Including a route parameter (passing the Hero `id` while routing to the "Hero Detail").
  * Child routes (the *Crisis Center* has its own routes).
  * The `CanActivate` guard (checking route access).
  * The `CanActivateChild` guard (checking child route access).
  * The `CanDeactivate` guard (ask permission to discard unsaved changes).
  * The `Resolve` guard (pre-fetching route data).
  * Lazy loading feature modules.
  * The `CanLoad` guard (check before loading feature module assets).

  The guide proceeds as a sequence of milestones as if you were building the app step-by-step.
  But, it is not a tutorial and it glosses over details of Angular application construction 
  that are more thoroughly covered elsewhere in the documentation.  

  The full source for the final version of the app can be seen and downloaded from the <live-example></live-example>.

:marked
  ### The sample application in action

  Imagine an application that helps the _Hero Employment Agency_ run its business.
  Heroes need work and the agency finds crises for them to solve.

  假设本程序会用来帮助“英雄管理局”运行他们的业务。
  英雄们需要找工作，而“英雄管理局”为它们寻找待解决的危机。

  The application has three main feature areas:

  1. A *Crisis Center* for maintaining the list of crises for assignment to heroes.
  1. A *Heroes* area for maintaining the list of heroes employed by the agency.
  1. An *Admin* area to manage the list of crises and heroes.

  Try it by clicking on this <live-example title="Hero Employment Agency Live Example">live example link</live-example>.
  
  Once the app warms up, you'll see a row of navigation buttons
  and the *Heroes* view with its list of heroes.

figure.image-display
  img(src='/resources/images/devguide/router/hero-list.png' alt="Hero List" width="250")

:marked
  Select one hero and the app takes you to a hero editing screen.

  选择其中之一，该应用就会把我们带到此英雄的编辑页面。
  
figure.image-display
  img(src='/resources/images/devguide/router/hero-detail.png' alt="Crisis Center Detail" width="250")

:marked
  Alter the name. 
  Click the "Back" button and the app returns to the heroes list which displays the changed hero name.
  Notice that the name change took effect immediately.

  修改会立即见效。我们再点击“后退”按钮，该应用又把我们带回了英雄列表页。

  Had you clicked the browser's back button instead of the "Back" button,
  the app would have returned you to the heroes list as well.
  Angular app navigation updates the browser history as normal web navigation does.

  另外我们也可以点击浏览器本身的后退按钮，这样也同样会回到英雄列表页。
  在Angular应用中导航也会和标准的Web导航一样更新浏览器中的历史。
  
  Now click the *Crisis Center* link for a list of ongoing crises.
  
  现在，点击*危机中心*链接，前往*危机*列表页。
  
figure.image-display
  img(src='/resources/images/devguide/router/crisis-center-list.png' alt="Crisis Center List" width="250")

:marked
  Select a crisis and the application takes you to a crisis editing screen.
  The _Crisis Detail_ appears in a child view on the same page, beneath the list. 
  
  选择其中之一，该应用就会把我们带到此危机的编辑页面。
  *危机详情*出现在了当前页的子视图区，也就是在列表的紧下方。

  Alter the name of a crisis. 
  Notice that the corresponding name in the crisis list does _not_ change.
  
figure.image-display
  img(src='/resources/images/devguide/router/crisis-center-detail.png' alt="Crisis Center Detail" width="250")

:marked
  Unlike *Hero Detail*, which updates as you type, 
  *Crisis Detail* changes are temporary until you either save or discard them by pressing the "Save" or "Cancel" buttons.
  Both buttons navigate back to the *Crisis Center* and its list of crises.
  
  这和*英雄详情*页略有不同。*英雄详情*会立即保存我们所做的更改。
  而*危机详情*页中，我们的更改都是临时的 —— 除非按“保存”按钮保存它们，或者按“取消”按钮放弃它们。
  这两个按钮都会导航回*危机中心*，显示危机列表。

  ***Do not click either button yet***.
  Click the browser back button or the "Heroes" link instead.
  
  ***先不要点击这些按钮***。
  而是点击浏览器的后退按钮，或者点击“Heroes”链接。

  Up pops a dialog box.
  
  我们会看到弹出了一个对话框。

figure.image-display
  img(src='/resources/images/devguide/router/confirm-dialog.png' alt="Confirm Dialog" width="250")

:marked
  You can say "OK" and lose your changes or click "Cancel" and continue editing.

  我们可以回答“确定”以放弃这些更改，或者回答“取消”来继续编辑。
  
  Behind this behavior is the router's `CanDeactivate` guard. 
  The guard gives you a chance to clean-up or ask the user's permission before navigating away from the current view.

  The `Admin` and `Login` buttons illustrate other router capabilities to be covered later in the guide.
  This short introduction will do for now.
  
  Proceed to the first application milestone.

.l-main-section#getting-started
:marked
  ## Milestone 1: Getting started with the router

  Begin with a simple version of the app that navigates between two empty views.
figure.image-display
  img(src='/resources/images/devguide/router/router-1-anim.gif' alt="App in action" width="250")

a#base-href
:marked
  ### Set the *&lt;base href>*
  
  ### 设置*&lt;base href>*  
  
  The router uses the browser's
  <a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries" target="_blank" title="HTML5 browser history push-state">history.pushState</a>
  for navigation. Thanks to `pushState`, you can make  in-app URL paths look the way you want them to
  look, e.g. `localhost:3000/crisis-center`. The in-app URLs can be indistinguishable from server URLs.

  路由器使用浏览器的<a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries" target="_blank" title="HTML5 browser history push-state">history.pushState</a>进行导航。
  感谢`pushState`！有了它，我们就能按所期望的样子来显示应用内部的URL路径，比如：`localhost:3000/crisis-center`。虽然我们使用的全部是客户端合成的视图，但应用内部的这些URL看起来和来自服务器的没有什么不同。

  Modern HTML5 browsers were the first to support `pushState` which is why many people refer to these URLs as
  "HTML5 style" URLs.
  
  现代HTML 5浏览器是最早支持`pushState`的，这也就是很多人喜欢把这种URL称作“HTML 5风格的”URL的原因。

.l-sub-section

  :marked
    HTML5 style navigation is the router default.
    In the [LocationStrategy and browser URL styles](#browser-url-styles) Appendix, 
    learn why HTML5 style is preferred, how to adjust its behavior, and how to switch to the
    older hash (#) style, if necessary.

    HTML 5风格的导航是路由器的默认值。请到下面的附录[浏览器URL风格](#browser-url-styles)中学习为什么首选“HTML 5”风格、如何调整它的行为，以及如何在必要时切换回老式的hash（#）风格。

:marked
  You must **add a
  <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base" target="_blank" title="base href">&lt;base href&gt; element</a>**
  to the app's `index.html` for `pushState` routing to work.
  The browser uses the `<base href>` value to prefix *relative* URLs when referencing
  CSS files, scripts, and images.

  Add the `<base>` element just after the  `<head>` tag.
  If the `app` folder is the application root, as it is for this application,
  set the `href` value in **`index.html`** *exactly* as shown here.

+makeExcerpt('src/index.html', 'base-href')

.callout.is-important
  header Live example note
  :marked
    A live coding environment like Plunker sets the application base address dynamically so you can't specify a fixed address.
    That's why the example code replaces the `<base href...>` with a script that writes the `<base>` tag on the fly.

  code-example(language="html").
    &lt;script>document.write('&lt;base href="' + document.location + '" />');&lt;/script>

  :marked
    You only need this trick for the live example, not production code.

    我们只应该在在线例子这种情况下使用这种小花招，不要把它用到产品的正式代码中。

a#import
:marked
  ### Importing from the router library
  
  ### 从路由库中导入

  Begin by importing some symbols from the router library.
  The Router is in its own `@angular/router` package.
  It's not part of the Angular core. The router is an optional service because not all applications
  need routing and, depending on your requirements, you may need a different routing library.
  
  先从路由库导入一些符号。
  路由器在它自己的`@angular/router`包中。
  它不是Angular内核的一部分。该路由器是可选的服务，这是因为并不是所有应用都需要路由，并且，如果需要，你还可能需要另外的路由库。

  You teach the router how to navigate by configuring it with routes.

  通过一些路由来配置路由器，我们可以教它如何进行导航。

a#route-config
:marked
  #### Define routes

  A router must be configured with a list of route definitions.
  
  路由器必须用“路由定义”的列表进行配置。

  The first configuration defines an array of two routes with simple paths leading to the
  `CrisisListComponent` and `HeroListComponent`.

  我们的第一个配置中定义了由两个路由构成的数组，它们分别通过路径(path)导航到了`CrisisListComponent`和`HeroListComponent`组件。

  Each definition translates to a [Route](../api/router/index/Route-interface.html) object which has two things: a
  `path`, the URL path segment for this route; and a
  `component`, the component associated with this route.

  每个定义都被翻译成了一个[Route](../api/router/index/Route-interface.html)对象。该对象有一个`path`字段，表示该路由中的URL路径部分，和一个`component`字段，表示与该路由相关联的组件。

  The router draws upon its registry of definitions when the browser URL changes
  or when application code tells the router to navigate along a route path.
  
  当浏览器的URL变化时或在代码中告诉路由器导航到一个路径时，路由器就会翻出它用来保存这些路由定义的注册表。

  In simpler terms, you might say this of the first route:
  
  直白的说，我们可以这样解释第一个路由：

  * When the browser's location URL changes to match the path segment `/crisis-center`, then
  the router activates an instance of the `CrisisListComponent` and displays its view.
  
      当浏览器地址栏的URL变化时，如果它匹配上了路径部分`/crisis-center`，路由器就会激活一个`CrisisListComponent`的实例，并显示它的视图。

  * When the application requests navigation to the path `/crisis-center`, the router
  activates an instance of `CrisisListComponent`, displays its view, and updates the
  browser's address location and history with the URL for that path.

      **当应用程序请求导航到路径`/crisis-center`时，路由器激活一个`CrisisListComponent`的实例，显示它的视图，并将该路径更新到浏览器地址栏和历史。**

:marked
  Here is the first configuration. Pass the array of routes, `appRoutes`, to the `RouterModule.forRoot` method.
  It returns a module, containing the configured `Router` service provider, plus other providers that the routing library requires. 
  Once the application is bootstrapped, the `Router` performs the initial navigation based on the current browser URL.

  下面是第一个配置。我们将路由数组传递到`RouterModule.forRoot`方法，该方法返回一个包含已配置的`Router`服务提供商模块和一些其它路由包需要的服务提供商。应用启动时，`Router`将在当前浏览器URL的基础上进行初始导航。

+makeExcerpt('src/app/app.module.1.ts', 'first-config')

.l-sub-section
  :marked
    Adding the configured `RouterModule` to the `AppModule` is sufficient for simple route configurations.
    As the application grows, you'll want to refactor the routing configuration into a separate file
    and create a **[Routing Module](#routing-module)**, a special type of `Service Module` dedicated to the purpose
    of routing in feature modules.

    作为简单的路由配置，将添加配置好的`RouterModule`到`AppModule`中就足够了。
    随着应用的成长，我们将需要将路由配置重构到单独的文件，并创建**[路由模块](#routing-module)** - 一种特别的、专门为特征模块的路由器服务的**服务模块**。

:marked
  Providing the `RouterModule` in the `AppModule` makes the Router available everywhere in the application.

  在`AppModule`中提供`RouterModule`，让该路由器在应用的任何地方都能被使用。

a#shell
:marked
  ### The *AppComponent* shell
  
  ### *AppComponent*外壳组件

  The root `AppComponent` is the application shell. It has a title, a navigation bar with two links,
  and a *router outlet* where the router swaps views on and off the page. Here's what you get:
  
  根组件`AppComponent`是本应用的壳。它在顶部有一个标题、一个带两个链接的导航条，在底部有一个*路由器插座*，路由器会在它所指定的位置上把视图切入或调出页面。就像下图中所标出的：

figure.image-display
  img(src='/resources/images/devguide/router/shell-and-outlet.png' alt="Shell" width="300" )

a#shell-template

:marked
  The corresponding component template looks like this:

  该组件所对应的模板是这样的：

+makeExcerpt('src/app/app.component.1.ts', 'template', '')

a#router-outlet
:marked
  ### *RouterOutlet*

  The `RouterOutlet` is a directive from the router library that marks
  the spot in the template where the router should display the views for that outlet.

  `RouterOutlet`是一个来自路由库的组件。
  路由器会在`<router-outlet>`标签中显示视图。

.l-sub-section

  :marked
    The router adds the `<router-outlet>` element to the DOM
    and subsequently inserts the navigated view element
    immediately _after_ the `<router-outlet>`.

    一个模板中只能有一个***未命名的***`<router-outlet>`。
    但路由器可以支持多个*命名的*插座（outlet），将来我们会涉及到这部分特性。

a#router-link
:marked
  ### *RouterLink* binding

  Above the outlet, within the anchor tags, you see
  [attribute bindings](template-syntax.html#attribute-binding) to
  the `RouterLink` directive that look like `routerLink="..."`.

  在插座上方的A标签中，有一个绑定`RouterLink`指令的[属性绑定](template-syntax.html#property-binding)，就像这样：`routerLink="..."`。我们从路由库中导入了`RouterLink`。

  The links in this example each have a string path, the path of a route that
  you configured earlier. There are no route parameters yet.

  例子中的每个链接都有一个字符串型的路径，也就是我们以前配置过的路由路径，但还没有指定路由参数。

  You can also add more contextual information to the `RouterLink` by providing query string parameters
  or a URL fragment for jumping to different areas on the page. Query string parameters
  are provided through the `[queryParams]` binding which takes an object (e.g. `{ name: 'value' }`), while the URL fragment
  takes a single value bound to the `[fragment]` input binding.

  我们还可以通过提供查询字符串参数为`RouterLink`提供更多情境信息，或提供一个URL片段（Fragment或hash）来跳转到本页面中的其它区域。
  查询字符串可以由`[queryParams]`绑定来提供，它需要一个对象型参数（如`{ name: 'value' }`），而URL片段需要一个绑定到`[fragment]`的单一值。

.l-sub-section

  :marked
    Learn about the how you can also use the _link parameters array_ in the [appendix below](#link-parameters-array).

    还可以到[后面的附录](#link-parameters-array)中学习如何使用**链接参数数组**。

a#router-link-active
:marked
  ### *RouterLinkActive* binding

  On each anchor tag, you also see [property bindings](template-syntax.html#property-binding) to
  the `RouterLinkActive` directive that look like `routerLinkActive="..."`.

  每个A标签还有一个到`RouterLinkActive`指令的[属性绑定](template-syntax.html#property-binding)，就像`routerLinkActive="..."`。

  The template expression to the right of the equals (=) contains a space-delimited string of CSS classes 
  that the Router will add when this link is active (and remove when the link is inactive).
  You can also set the `RouterLinkActive` directive to a string of classes such as `[routerLinkActive]="active fluffy"`
  or bind it to a component property that returns such a string.

  等号（=）右侧的模板表达式包含用空格分隔的一些CSS类。当路由激活时路由器就会把它们添加到此链接上（反之则移除）。我们还可以把`RouterLinkActive`指令绑定到一个CSS类组成的数组，如`[routerLinkActive]="['...']"`。

  The `RouterLinkActive` directive toggles css classes for active `RouterLink`s based on the current `RouterState`.
  This cascades down through each level of the route tree, so parent and child router links can be active at the same time.
  To override this behavior, you can bind to the `[routerLinkActiveOptions]` input binding with the `{ exact: true }` expression.
  By using `{ exact: true }`, a given `RouterLink` will only be active if its URL is an exact match to the current URL.

  `RouterLinkActive`指令会基于当前的`RouterState`对象来为激活的`RouterLink`切换CSS类。
  这会一直沿着路由树往下进行级联处理，所以父路由链接和子路由链接可能会同时激活。
  要改变这种行为，可以把`[routerLinkActiveOptions]`绑定到`{exact: true}`表达式。
  如果使用了`{ exact: true }`，那么只有在其URL与当前URL精确匹配时才会激活指定的`RouterLink`。

a#router-directives
:marked
  ### *Router directives*
  
  ### *路由器指令集*

  `RouterLink`, `RouterLinkActive` and `RouterOutlet` are directives provided by the Angular `RouterModule` package.
  They are readily available for you to use in the template.

  `RouterLink`、`RouterLinkActive`和`RouterOutlet`是由`RouterModule`包提供的指令。
  现在它已经可用于我们自己的模板中。
:marked
  The current state of `app.component.ts` looks like this:

  `app.component.ts`目前看起来是这样的：

+makeExcerpt('src/app/app.component.1.ts')

a#wildcard
:marked
  ### Wildcard route

  You've created two routes in the app so far, one to `/crisis-center` and the other to `/heroes`. 
  Any other URL causes the router to throw an error and crash the app.
  
  Add a **wildcard** route to intercept invalid URLs and handle them gracefully. 
  A _wildcard_ route has a path consisting of two asterisks. It matches _every_ URL. 
  The router will select _this_ route if it can't match a route earlier in the configuration.
  A wildcard route can navigate to a custom "404 Not Found" component or [redirect](#redirect) to an existing route.

.l-sub-section
  :marked
    The router selects the route with a [_first match wins_](#example-config) strategy.
    Wildcard routes are the least specific routes in the route configuration.
    Be sure it is the _last_ route in the configuration.

:marked
  To test this feature, add a button with a `RouterLink` to the `HeroListComponent` template and set the link to `"/sidekicks"`. 
+makeExcerpt('src/app/hero-list.component.ts')
:marked
  The application will fail if the user clicks that button because you haven't defined a `"/sidekicks"` route yet. 
  
  Instead of adding the `"/sidekicks"` route, define a `wildcard` route instead and have it navigate to a simple `PageNotFoundComponent`.
+makeExcerpt('src/app/app.module.1.ts', 'wildcard')

:marked
  Create the `PageNotFoundComponent` to display when users visit invalid URLs.
+makeExcerpt('src/app/not-found.component.ts (404 component)', '')

:marked
  As with the other components, add the `PageNotFoundComponent` to the `AppModule` declarations.

  Now when the user visits `/sidekicks`, or any other invalid URL, the browser displays "Page not found".
  The browser address bar continues to point to the invalid URL.


a#default-route
:marked
  ### The _default_ route to heroes

  When the application launches, the initial URL in the browser bar is something like:

code-example.
  localhost:3000

:marked
  That doesn't match any of the configured routes which means that the application won't display any component when it's launched.
  The user must click one of the links to trigger a navigation and display a component.

  It would be nicer if the application had a **default route** that displayed the list of heroes immediately,
  just as it will when the user clicks the "Heroes" link or pastes `localhost:3000/heroes` into the address bar.

a#redirect
:marked
  ### Redirecting routes

  The preferred solution is to add a `redirect` route that translates the initial relative URL (`''`)
  to the desired default path (`/heroes`). The browser address bar shows `.../heroes` as if you'd navigated there directly.

  Add the default route somewhere _above_ the wildcard route.
  It's just above the wildcard route in the following excerpt showing the complete `appRoutes` for this milestone.

+makeExcerpt('src/app/app-routing.module.1.ts' , 'appRoutes')

:marked
  A redirect route requires a `pathMatch` property to tell the router how to match a URL to the path of a route.
  The router throws an error if you don't.
  In this app, the router should select the route to the `HeroListComponent` only when the *entire URL* matches `''`,
  so set the `pathMatch` value to `'full'`.

.l-sub-section
  :marked
    Technically, `pathMatch = 'full'` results in a route hit when the *remaining*, unmatched segments of the URL match `''`.
    In this example, the redirect is in a top level route so the *remaining* URL and the *entire* URL are the same thing.

    The other possible `pathMatch` value is `'prefix'` which tells the router
    to match the redirect route when the *remaining* URL ***begins*** with the redirect route's _prefix_ path.

    Don't do that here. 
    If the `pathMatch` value were `'prefix'`, _every_ URL would match `''`.

    Try setting it to `'prefix'` then click the `Go to sidekicks` button.
    Remember that's a bad URL and you should see the "Page not found" page.
    Instead, you're still on the "Heroes" page.
    Enter a bad URL in the browser address bar. 
    You're instantly re-routed to `/heroes`.
    _Every_ URL, good or bad, that falls through to _this_ route definition
    will be a match. 

    The default route should redirect to the `HeroListComponent` _only_ when the _entire_ url is  `''`.
    Remember to restore the redirect to `pathMatch = 'full'`.

    Learn more in Victor Savkin's 
    [post on redirects](http://victorsavkin.com/post/146722301646/angular-router-empty-paths-componentless-routes).

:marked
  ### Basics wrap up

  ### “起步阶段”总结

  You've got a very basic navigating app, one that can switch between two views
  when the user clicks a link.

  我们得到了一个非常基本的、带导航的应用，当用户点击链接时，它能在两个视图之间切换。

  You've learned how to do the following:

  我们已经学会了如何：

  * Load the router library.

    加载路由库

  * Add a nav bar to the shell template with anchor tags, `routerLink`  and `routerLinkActive` directives.

    往壳组件的模板中添加一个导航条，导航条中有一些A标签、`routerLink`指令和`routerLinkActive`指令

  * Add a `router-outlet` to the shell template where views will be displayed.

    往壳组件的模板中添加一个`router-outlet`指令，视图将会被显示在那里

  * Configure the router module with `RouterModule.forRoot`.

    用`RouterModule.forRoot`配置路由器模块

  * Set the router to compose HTML5 browser URLs.

    设置路由器，使其合成HTML5模式的浏览器URL。
  
  * handle invalid routes with a `wildcard` route.

    使用通配符路由来处理无效路由
  
  * navigate to the default route when the app launches with an empty path.

    当应用在空路径下启动时，导航到默认路由


  The rest of the starter app is mundane, with little interest from a router perspective.
  Here are the details for readers inclined to build the sample through to this milestone.

  这个初学者应用的其它部分有点平淡无奇，从路由器的角度来看也很平淡。
  如果你还是倾向于在这个里程碑里构建它们，参见下面的构建详情。

  The starter app's structure looks like this:

  这个初学者应用的结构看起来是这样的：

.filetree
  .file router-sample
  .children
    .file src
    .children
      .file app
      .children
        .file app.component.ts
        .file app.module.ts
        .file crisis-list.component.ts
        .file hero-list.component.ts
        .file not-found.component.ts
      .file main.ts
      .file index.html
      .file styles.css
      .file tsconfig.json
    .file node_modules ...
    .file package.json
:marked
  Here are the files discussed in this milestone.

  下面是当前里程碑中讨论过的文件列表：

+makeTabs(
  `router/ts/src/app/app.component.1.ts,
  router/ts/src/app/app.module.1.ts,
  router/ts/src/main.ts,
  router/ts/src/app/hero-list.component.ts,
  router/ts/src/app/crisis-list.component.ts,
  router/ts/src/app/not-found.component.ts,
  router/ts/src/index.html`,
  ',,,,',
  `app.component.ts,
  app.module.ts,
  main.ts,
  hero-list.component.ts,
  crisis-list.component.ts,
  not-found.component.ts,
  index.html`)

.l-main-section#routing-module
:marked
  ## Milestone 2: *Routing module*

  ## 里程碑 #2：**路由模块**

  In the initial route configuration, you provided a simple setup with two routes used
  to configure the application for routing. This is perfectly fine for simple routing.
  As the application grows and you make use of more `Router` features, such as guards,
  resolvers, and child routing, you'll naturally want to refactor the routing configuration into its own file. 
  We recommend moving the routing information into a special-purpose module called a *Routing Module*.
  
  在原始的路由配置中，我们提供了仅有两个路由的简单配置来设置应用的路由。对于简单的路由，这没有问题。
    随着应用的成长，我们使用更多**路由器**特征，比如守卫、解析器和子路由等，我们很自然想要重构路由。
    建议将路由信息移到一个单独的特殊用途的模块，叫做**路由模块**。

  The **Routing Module** has several characteristics:
  
  **路由模块**有一系列特性：
  
  * Separates routing concerns from other application concerns.
  
    把路由这个关注点从其它应用类关注点中分离出去
    
  * Provides a module to replace or remove when testing the application.
  
    测试特征模块时，可以替换或移除路由模块
    
  * Provides a well-known location for routing service providers including guards and resolvers.
  
    为路由服务提供商（包括守卫和解析器等）提供一个共同的地方
    
  * Does **not** [declare components](../cookbook/ngmodule-faq.html#routing-module).
  
    **不要**[声明组件](../cookbook/ngmodule-faq.html#routing-module)

a#routing-refactor
:marked
  ### Refactor the routing configuration into a _routing module_
  
  ### 将路由配置重构为*路由模块*

  Create a file named `app-routing.module.ts` in the `/app` folder to contain the routing module. 
  
  在`/app`目录下创建一个名叫`app-routing.module.ts`的文件，以包含这个路由模块。

  Import the `CrisisListComponent` and the `HeroListComponent` components
  just like you did in the `app.module.ts`. Then move the `Router` imports
  and routing configuration, including `RouterModule.forRoot`, into this routing module.
  
  导入`CrisisListComponent`和`HeroListComponent`组件，就像`app.module.ts`中一样。然后把`Router`的导入语句和路由配置以及`RouterModule.forRoot`移入这个路由模块中。

  Following convention, add a class name `AppRoutingModule` and export it
  so you can import it later in `AppModule`.

  Finally, re-export the Angular `RouterModule` by adding it to the module `exports` array. 
  By re-exporting the `RouterModule` here and importing `AppRoutingModule` in `AppModule`,
  the components declared in `AppModule` will have access to router directives such as `RouterLink` and `RouterOutlet`.

  After these steps, the file should look like this.
+makeExample('src/app/app-routing.module.1.ts')
:marked
   Next, update the `app.module.ts` file, 
   first importing the newly created `AppRoutingModule`from `app-routing.module.ts`,
   then replacing `RouterModule.forRoot` in the `imports` array with the `AppRoutingModule`.
+makeExample('src/app/app.module.2.ts')
.l-sub-section
  :marked
    Later in this guide you will create [multiple routing modules](#hero-routing-module) and discover that
    you must import those routing modules [in the correct order](#routing-module-order).

:marked
  The application continues to work just the same, and you can use `AppRoutingModule` as
  the central place to maintain future routing configuration.

  应用继续正常运行，我们可以把路由模块作为为每个特征模块维护路由配置的中心地方。

a#why-routing-module
:marked
  ### Do you need a _Routing Module_?

  ### 你需要**路由模块**吗？

  The _Routing Module_ *replaces* the routing configuration in the root or feature module.
  _Either_ configure routes in the Routing Module _or_ within the module itself but not in both.

  **路由模块**在根模块或者特征模块替换了路由配置。在路由模块或者在模块内部配置路由，但不要同时在两处都配置。

  The Routing Module is a design choice whose value is most obvious when the configuration is complex
  and includes specialized guard and resolver services.
  It can seem like overkill when the actual configuration is dead simple.

  路由模块是设计选择，它的价值在配置很复杂，并包含专门守卫和解析器服务时尤其明显。
  在配置很简单时，它可能看起来很多余。

  Some developers skip the Routing Module (for example, `AppRoutingModule`) when the configuration is simple and
  merge the routing configuration directly into the companion module (for example, `AppModule`).

  在配置很简单时，一些开发者跳过路由模块（例如`AppRoutingModule`），并将路由配置直接混合在关联模块中（比如`AppModule` ）。

  Choose one pattern or the other and follow that pattern consistently.

  我们建议你选择其中一种模式，并坚持模式的一致性。

  Most developers should always implement a Routing Module for the sake of consistency.

  大多数开发者应该采用路由模块，以保持一致性。

  It keeps the code clean when configuration becomes complex.
  It makes testing the feature module easier.
  Its existence calls attention to the fact that a module is routed.
  It is where developers expect to find and expand routing configuration.

  它在配置复杂时，能确保代码干净。
  它让测试特征模块更加容易。
  它的存在突出了模块时被路由的事实。
  开发者可以很自然的从路由模块中查找和扩展路由配置。

.l-main-section#heroes-feature
:marked
  ## Milestone 3: Heroes feature

  ## 里程碑 #2 英雄特征区

  You've seen how to navigate using the `RouterLink` directive.
  Now you'll learn the following:
  
  我们刚刚学习了如何用`RouterLink`指令进行导航。接下来我们将到：
  
  * Organize the app and routes into *feature areas* using modules.
      
      用模块把应用和路由组织为一些*特性区*
      
  * Navigate imperatively from one component to another.
  
      命令式地从一个组件导航到另一个组件
      
  * Pass required and optional information in route parameters.
  
      通过路由传递必要信息和可选信息

  This example recreates the heroes feature in the "Services" episode of the
  [Tour of Heroes tutorial](../tutorial/toh-pt4.html "Tour of Heroes: Services"),
  and you'll be copying much of the code 
  from the <live-example name="toh-4" title="Tour of Heroes: Services example code"></live-example>.

  Here's how the user will experience this version of the app:

figure.image-display
  img(src='/resources/images/devguide/router/router-2-anim.gif' alt="App in action" )

:marked
  A typical application has multiple *feature areas*, 
  each dedicated to a particular business purpose.

  While you could continue to add files to the `src/app/` folder,
  that is unrealistic and ultimately not maintainable.
  Most developers prefer to put each feature area in its own folder.

  You are about to break up the app into different *feature modules*, each with its own concerns.
  Then you'll import into the main module and navigate among them. 

a#heroes-functionality
:marked
  ### Add heroes functionality

  Follow these steps:
  
  * Create the `src/app/heroes` folder; you'll be adding files implementing *hero management* there.
  * Delete the placeholder `hero-list.component.ts` that's in the `app` folder.
  * Create a new `hero-list.component.ts` under `src/app/heroes`.
  * Copy into it the contents of the `app.component.ts` from
    the <live-example name="toh-4" title="Tour of Heroes: Services example code">"Services" tutorial</live-example>.
  * Make a few minor but necessary changes:

    * Delete the `selector` (routed components don't need them).
    * Delete the `<h1>`.
    * Relabel the `<h2>` to `<h2>HEROES</h2>`.
    * Delete the `<hero-detail>` at the bottom of the template.
    * Rename the `AppComponent` class to `HeroListComponent`.

  * Copy the `hero-detail.component.ts` and the `hero.service.ts` files into the `heroes` subfolder.
  * Create a (pre-routing) `heroes.module.ts` in the heroes folder that looks like this:

+makeExample('src/app/heroes/heroes.module.ts', 'v1','src/app/heroes/heroes.module.ts (pre-routing)')

:marked
  When you're done, you'll have these *hero management* files:

  安排完这些，我们就有了四个*英雄管理*特性区的文件：

.filetree
  .file src/app/heroes
  .children
    .file hero-detail.component.ts
    .file hero-list.component.ts
    .file hero.service.ts
    .file heroes.module.ts

a#hero-routing-requirements
:marked
  ### *Hero* feature routing requirements

  ### *英雄*特性区的路由需求

  The heroes feature has two interacting components, the hero list and the hero detail.
  The list view is self-sufficient; you navigate to it, it gets a list of heroes and displays them.

  “英雄”特性有两个相互协作的组件，列表和详情。
  列表视图是自给自足的，我们导航到它，它会自行获取英雄列表并显示它们。

  The detail view is different. It displays a particular hero. It can't know which hero to show on its own.
  That information must come from outside.
  
  详情视图就不同了。它要显示一个特定的英雄，但是它本身却无法知道显示哪一个，此信息必须来自外部。

  When the user selects a hero from the list, the app should navigate to the detail view 
  and show that hero.
  You tell the detail view which hero to display by including the selected hero's id in the route URL.
  
  当用户从列表中选择了一个英雄时，我们就导航到详情页以显示那个英雄。
    通过把所选英雄的id编码进路由的URL中，就能告诉详情视图该显示哪个英雄。

a#hero-routing-module
:marked
  ### *Hero* feature route configuration

  ### *英雄*特性区的路由配置

  Create a new `heroes-routing.module.ts` in the `heroes` folder
  using the same techniques you learned while creating the `AppRoutingModule`.

+makeExample('src/app/heroes/heroes-routing.module.ts','','src/app/heroes/heroes-routing.module.ts')

.l-sub-section
  :marked
    Put the routing module file in the same folder as its companion module file.
    Here both `heroes-routing.module.ts` and `heroes.module.ts` are in the same `src/app/heroes` folder.

    Consider giving each feature module its own route configuration file.
    It may seem like overkill early when the feature routes are simple.
    But routes have a tendency to grow more complex and consistency in patterns pays off over time.

    将路由模块文件放到它相关的模块文件所在目录里。
    这里，`heroes-routing.module.ts`和`heroes.module.ts`都在`app/heroes`目录中。

:marked
  Import the hero components from their new locations in the `src/app/heroes/` folder, define the two hero routes,
  and export the `HeroRoutingModule` class.

  Now that you have routes for the `Heroes` module, register them with the `Router` via the 
  `RouterModule` _almost_ as you did in the `AppRoutingModule`.
  
  现在，我们有了`Heroes`模块的路由，还得在`RouterModule`中把它们注册给*路由器*，和`AppRoutingModule`中的做法几乎完全一样。
  
  There is a small but critical difference.
  In the `AppRoutingModule`, you used the static **`RouterModule.forRoot`** method to register the routes and application level service providers. 
  In a feature module you use the static **`forChild`** method.

  这里有少量但是关键的不同点。
  在`AppRoutingModule`中，我们使用了静态的`RouterModule.`**`forRoot`**方法来注册我们的路由和全应用级服务提供商。
  在特性模块中，我们要改用**`forChild`**静态方法。

.l-sub-section
  :marked
    Only call `RouterModule.forRoot` in the root `AppRoutingModule` 
    (or the `AppModule` if that's where you register top level application routes). 
    In any other module, you must call the **`RouterModule.forChild`** method to register additional routes.
    
    **RouterModule.forRoot**只能由`AppModule`提供。但我们位于特性模块中，所以使用**`RouterModule.forChild`**来单独注册更多路由。
    
a#adding-routing-module
:marked
  ### Add the routing module to the _HeroesModule_
  Add the `HeroRoutingModule` to the `HeroModule`
  just as you added `AppRoutingModule` to the `AppModule`.
  
  我们在`Heroes`模块中从`heroes-routing.module.ts`中导入`HeroRoutingModule`，并注册其路由。

  Open `heroes.module.ts`.
  Import the `HeroRoutingModule` token from `heroes-routing.module.ts` and 
  add it to the `imports` array of the `HeroesModule`. 
  The finished `HeroesModule` looks like this:

+makeExample('src/app/heroes/heroes.module.ts','','src/app/heroes/heroes.module.ts')

a#remove-duplicate-hero-routes
:marked
  ### Remove duplicate hero routes

  The hero routes are currently defined in _two_ places: in the `HeroesRoutingModule`,
  by way of the `HeroesModule`, and in the `AppRoutingModule`.

  Routes provided by feature modules are combined together into their imported module's routes by the router. 
  This allows you to continue defining the feature module routes without modifying the main route configuration.

  But you don't want to define the same routes twice.
  Remove the `HeroListComponent` import and the `/heroes` route from the `app-routing.module.ts`.

  **Leave the default and the wildcard routes!**
  These are concerns at the top level of the application itself.

+makeExcerpt('src/app/app-routing.module.2.ts (v2)', '')

a#merge-hero-routes 
:marked
  ### Import hero module into AppModule
  The heroes feature module is ready, but the application doesn't know about the `HeroesModule` yet.
  Open `app.module.ts` and revise it as follows.
  
  Import the `HeroesModule` and add it to the `imports` array in the `@NgModule` metadata of the `AppModule`.
  
  Remove the `HeroListComponent` from the `AppModule`'s `declarations` because it's now provided by the `HeroesModule`.
  This is important. There can be only _one_ owner for a declared component. 
  In this case, the `Heroes` module is the owner of the `Heroes` components and is making them available to 
  components in the `AppModule` via the `HeroesModule`.

  As a result, the `AppModule` no longer has specific knowledge of the hero feature, its components, or its route details.
  You can evolve the hero feature with more components and different routes.
  That's a key benefit of creating a separate module for each feature area.  

  After these steps, the `AppModule` should look like this:

+makeExample('src/app/app.module.3.ts','','src/app/app.module.ts')

a#routing-module-order
:marked
  ### Module import order matters

  Look at the module `imports` array. Notice that the `AppRoutingModule` is _last_.
  Most importantly, it comes _after_ the `HeroesModule`.
+makeExample('src/app/app.module.3.ts','module-imports','src/app/app.module.ts (module-imports)')(format='.')

:marked
  The order of route configuration matters. 
  The router accepts the first route that matches a navigation request path.

  When all routes were in one `AppRoutingModule`, 
  you put the default and [wildcard](#wildcard) routes last, after the `/heroes` route,
  so that the router had a chance to match a URL to the `/heroes` route _before_
  hitting the wildcard route and navigating to "Page not found".

  The routes are no longer in one file. 
  They are distributed across two modules, `AppRoutingModule` and `HeroesRoutingModule`.

  Each routing module augments the route configuration _in the order of import_.
  If you list `AppRoutingModule` first, the wildcard route will be registered
  _before_ the hero routes.
  The wildcard route &mdash; which matches _every_ URL &mdash; 
  will intercept the attempt to navigate to a hero route.

.l-sub-section
  :marked
    Reverse the routing modules and see for yourself that
    a click of the heroes link results in "Page not found".
    Learn about inspecting the runtime router configuration
    [below](#inspect-config "Inspect the router config").

a#route-def-with-parameter
:marked
  ### Route definition with a parameter

  ### 带参数的路由定义

  Return to the `HeroesRoutingModule` and look at the route definitions again.
  The route to `HeroDetailComponent` has a twist.

  回到`HeroesRoutingModule`并再次检查这些路由定义。
  `HeroDetailComponent`的路由有点特殊。

+makeExcerpt('src/app/heroes/heroes-routing.module.ts (excerpt)', 'hero-detail-route')

:marked
  Notice the `:id` token in the path. That creates a slot in the path for a **Route Parameter**.
  In this case, the router will insert the `id` of a hero into that slot.

  注意路径中的`:id`令牌。它为*路由参数*在路径中创建一个“空位”。在这里，我们期待路由器把英雄的`id`插入到那个“空位”中。

  If you tell the router to navigate to the detail component and display "Magneta", 
  you expect a hero id to appear in the browser URL like this:

  如果要告诉路由器导航到详情组件，并让它显示“Magneta”，我们会期望这个英雄的`id`像这样显示在浏览器的URL中：


code-example(format="nocode").
  localhost:3000/hero/15

:marked
  If a user enters that URL into the browser address bar, the router should recognize the
  pattern and go to the same "Magneta" detail view.

  如果用户把此URL输入到浏览器的地址栏中，路由器就会识别出这种模式，同样进入“Magneta”的详情视图。

.callout.is-helpful
  header Route parameter: Required or optional?
  :marked
    Embedding the route parameter token, `:id`, 
    in the route definition path is a good choice for this scenario
    because the `id` is *required* by the `HeroDetailComponent` and because
    the value `15` in the path clearly distinguishes the route to "Magneta" from
    a route for some other hero.
    
    在这个场景下，把路由参数的令牌`:id`嵌入到路由定义的`path`中是一个好主意，因为对于`HeroDetailComponent`来说`id`是*必须的*，
    而且路径中的值`15`已经足够把到“Magneta”的路由和到其它英雄的路由明确区分开。

a#navigate
:marked
  ### Navigate to hero detail imperatively

  ### 命令式地导航到英雄详情

  Users *will not* navigate to the detail component by clicking a link
  so you won't add a new `RouterLink` anchor tag to the shell.

  *这次我们不打算通过点击链接来导航到详情组件*，因此也不用再把带`RouterLink`的新的A标签加到壳组件中。

  Instead, when the user *clicks* a hero in the list, you'll ask the router
  to navigate to the hero detail view for the selected hero.

  而是改为当用户在列表中*点击*一个英雄时，我们将*要求*路由器导航到所选英雄的详情视图

  Start in the `HeroListComponent`.
  Revise its constructor so that it acquires the `Router` and the `HeroService` by dependency injection:
  
  从`HeroListComponent`开始。
  修改它的构造函数，让它通过依赖注入获得`Router`和`HeroService`：

+makeExcerpt('src/app/heroes/hero-list.component.1.ts (constructor)', 'ctor')

:marked
  Make the following few changes to the component's template:

  还要对模板进行一点修改：

+makeExcerpt('src/app/heroes/hero-list.component.1.ts', 'template', '')

:marked
  The template defines an `*ngFor` repeater such as [you've seen before](displaying-data.html#ngFor).
  There's a `(click)` [event binding](template-syntax.html#event-binding) to the component's 
  `onSelect` method which you implement as follows:

  模板像[以前](displaying-data.html#ngFor)一样定义了一个`*ngFor`重复器。
  还有一个`(click)`[事件绑定](template-syntax.html#event-binding)，绑定到了组件的`onSelect`方法，就像这样：

+makeExcerpt('src/app/heroes/hero-list.component.1.ts', 'select')

:marked
  The component's `onSelect` calls the router's **`navigate`** method with a _link parameters array_.
  You can use this same syntax in a `RouterLink` if you decide later to navigate in HTML template rather than in component code.

  它用一个**链接参数数组**调用路由器的**`navigate`**方法。
  如果我们想把它用在HTML中，那么也可以把相同的语法用在`RouterLink`中。


a#route-parameters
:marked
  ### Setting the route parameters in the list view
  
  After navigating to the `HeroDetailComponent`, you expect to see the details of the selected hero.
  You need *two* pieces of information: the routing path to the component and the hero's `id`.

  我们将导航到`HeroDetailComponent`组件。在那里，我们期望看到所选英雄的详情，这需要两部分信息：导航目标和该英雄的`id`。

  Accordingly, the _link parameters array_ has *two* items:  the routing _path_ and a _route parameter_ that specifies the
  `id` of the selected hero.

  因此，这个*链接参数数组*中有两个条目：目标路由的**`path`（路径）**，和一个用来指定所选英雄`id`的**路由参数**。

+makeExcerpt('src/app/heroes/hero-list.component.1.ts', 'link-parameters-array')

:marked
  The router composes the destination URL from the array like this:
  `localhost:3000/hero/15`.
  
  路由器从该数组中组合出了目标URL：
  `localhost:3000/hero/15`。


.l-sub-section
  :marked
    How does the target `HeroDetailComponent` learn about that `id`?
    Don't analyze the URL. Let the router do it.

    目标组件`HeroDetailComponent`该怎么知道这个`id`参数呢？
    当然不会是自己去分析URL了！那是路由器的工作。
    
    The router extracts the route parameter (`id:15`) from the URL and supplies it to
    the `HeroDetailComponent` via the `ActivatedRoute` service.
  
    路由器从URL中解析出路由参数（`id:15`），并通过**ActivatedRoute**服务来把它提供给`HeroDetailComponent`组件。

a#activated-route
:marked
  ### ActivatedRoute: the one-stop-shop for route information

  每个路由都包含路径、数据参数、URL片段等很多信息。
  所有这些信息都可以通过有路由器提供的一个叫[ActivatedRoute](../api/router/index/ActivatedRoute-interface.html)的服务提供商来获取。

  The route path and parameters are available through an injected router service called the
  [ActivatedRoute](../api/router/index/ActivatedRoute-interface.html).
  It has a great deal of useful information including:

  该路由的路径和参数可以通过注入进来的一个名叫[ActivatedRoute](../api/router/index/ActivatedRoute-interface.html)的路由服务来获取。
  它有一大堆有用的信息，包括：

.l-sub-section
  :marked
    **`url`**: An `Observable` of the route path(s), represented as an array of strings for each part of the route path.

    **`url`**: 该路由路径的`Observable`对象。它的值是一个由路径中各个部件组成的字符串数组。

    **`data`**: An `Observable` that contains the `data` object provided for the route. Also contains any resolved values from the [resolve guard](#resolve-guard).

    **`data`**: 该路由提供的`data`对象的一个`Observable`对象。还包含从[resolve守卫](#resolve-guard)中解析出来的值。

    **`params`**: An `Observable` that contains the required and [optional parameters](#optional-route-parameters) specific to the route.

    **`params`**: 包含该路由的必选参数和[可选参数](#optional-route-parameters)的`Observable`对象。

    **`queryParams`**: An `Observable` that contains the [query parameters](#query-parameters) available to all routes.

    **`queryParams`**: 一个包含对所有路由都有效的[查询参数](#query-parameters)的`Observable`对象。

    **`fragment`**:  An `Observable` of the URL [fragment](#fragment) available to all routes.

    **`fragment`**:  一个包含对所有路由都有效的[片段](#fragment)值的`Observable`对象。

    **`outlet`**: The name of the `RouterOutlet` used to render the route. For an unnamed outlet, the outlet name is _primary_.

    **`outlet`**: `RouterOutlet`的名字，用于指示渲染该路由的位置。对于未命名的`RouterOutlet`，这个名字是**primary**。

    **`routeConfig`**: The route configuration used for the route that contains the origin path.

    **`routeConfig`**: 与该路由的原始路径对应的配置信息。

    **`parent`**: an `ActivatedRoute` that contains the information from the parent route when using [child routes](#child-routing-component).

    **`parent`**: 当使用[子路由](#child-routing-component)时，它是一个包含父路由信息的`ActivatedRoute`对象。

    **`firstChild`**: contains the first `ActivatedRoute` in the list of child routes.

    **`firstChild`**: 包含子路由列表中的第一个`ActivatedRoute`对象。

    **`children`**: contains all the [child routes](#child-routing-component) activated under the current route.

    **`children`**: 包含当前路由下激活的全部[子路由](#child-routing-component)。

:marked
  Import the `Router`, `ActivatedRoute`, and `Params` tokens from the router package.

  我们要从路由器（`router`）包中导入`Router`、`ActivatedRoute`和`Params`类。

+makeExcerpt('src/app/heroes/hero-detail.component.1.ts (activated route)', 'imports')

:marked
  Import the `switchMap` operator because you need it later to process the `Observable` route parameters.

+makeExcerpt('src/app/heroes/hero-detail.component.ts (switchMap operator import)', 'rxjs-operator-import')

a#hero-detail-ctor
:marked
  As usual, you write a constructor that asks Angular to inject services
  that the component requires and reference them as private variables.

  通常，我们会直接写一个构造函数，让Angular把组件所需的服务注入进来，自动定义同名的私有变量，并把它们存进去。

+makeExcerpt('src/app/heroes/hero-detail.component.ts (constructor)', 'ctor')

:marked
  Later, in the `ngOnInit` method, you use the `ActivatedRoute` service to retrieve the parameters for the route,
  pull the hero `id` from the parameters and retrieve the hero to display.
  
  然后，在`ngOnInit`方法中，我们用`ActivatedRoute`服务来接收路由的参数，从参数中取得该英雄的`id`，并接收此英雄用于显示。

.l-sub-section
  :marked
    Put this data access logic in the `ngOnInit` method rather than inside the constructor to improve the component's testability.
    Angular calls the `ngOnInit` method shortly after creating an instance of the `HeroDetailComponent`
    so the hero will be retrieved in time to use it.
      
    Learn more about the `ngOnInit` method and other component lifecycle hooks in the [Lifecycle Hooks](lifecycle-hooks.html) guide.

+makeExcerpt('src/app/heroes/hero-detail.component.ts (ngOnInit)', 'ngOnInit')

:marked
  Since the parameters are provided as an `Observable`, you use the `switchMap` operator to
  provide them for the `id` parameter by name and tell the `HeroService` to fetch the hero with that `id`.

  The `switchMap` operator allows you to perform an action with the current value of the `Observable`,
  and map it to a new `Observable`. As with many `rxjs` operators, `switchMap` handles
  an `Observable` as well as a `Promise` to retrieve the value they emit.

  `switchMap`允许你在`Observable`的当前值上执行一个动作，并将它映射一个新的`Observable`。像许多其它`rxjs`操作符一样，
  `switchMap`既可以处理`Observable`也可以处理`Promise`发射的值。

  The `switchMap` operator will also cancel any in-flight requests if the user re-navigates to the route
  while still retrieving a hero. 
  
  如果用户重新导航到该路由，并且它正在获取一个英雄时，`switchMap`操作符还将取消任何正在执行的请求。
  
  Use the `subscribe` method to detect `id` changes and to (re)set the retrieved `Hero`.
  
  使用`subscribe`方法来检测`id`的变化，并据此重新获取英雄。

a#reuse
:marked
  #### Observable <i>params</i> and component reuse
  
  #### <i>参数</i>的可观察对象（Observable）与组件复用

  In this example, you retrieve the route params from an `Observable`.
  That implies that the route params can change during the lifetime of this component.

  在这个例子中，我们订阅了路由参数的`Observable`对象。
  这种写法暗示着这些路由参数在该组件的生存期内可能会变化。

  They might. By default, the router re-uses a component instance when it re-navigates to the same component type
  without visiting a different component first. The route parameters could change each time.

  确实如此！默认情况下，如果它没有访问过其它组件就导航到了同一个组件实例，那么路由器倾向于复用组件实例。如果复用，这些参数可以变化。

  Suppose a parent component navigation bar had "forward" and "back" buttons
  that scrolled through the list of heroes.
  Each click navigated imperatively to the `HeroDetailComponent` with the next or previous `id`.

  假设父组件的导航栏有“前进”和“后退”按钮，用来轮流显示英雄列表中中英雄的详情。
    每次点击都会强制导航到带前一个或后一个`id`的`HeroDetailComponent`组件。
    
  You don't want the router to remove the current `HeroDetailComponent` instance from the DOM only to re-create it for the next `id`.
  That could be visibly jarring.
  Better to simply re-use the same component instance and update the parameter.
  
  我们不希望路由器仅仅从DOM中移除当前的`HeroDetailComponent`实例，并且用下一个`id`重新创建它。
    那可能导致界面抖动。
    更好的方式是复用同一个组件实例，并更新这些参数。

  Unfortunately, `ngOnInit` is only called once per component instantiation.
  You need a way to detect when the route parameters change from _within the same instance_.
  The observable `params` property handles that beautifully.
  
  不幸的是，`ngOnInit`对每个实例只调用一次。
    我们需要一种方式来检测_在同一个实例中_路由参数什么时候发生了变化。
    而`params`属性这个可观察对象（Observable）干净漂亮的处理了这种情况。

.l-sub-section
  :marked
    When subscribing to an observable in a component, you almost always arrange to unsubscribe when the component is destroyed.
    
    There are a few exceptional observables where this is not necessary. 
    The `ActivatedRoute` observables are among the exceptions.

    The `ActivatedRoute` and its observables are insulated from the `Router` itself.
    The `Router` destroys a routed component when it is no longer needed and the injected `ActivatedRoute` dies with it.

    Feel free to unsubscribe anyway. It is harmless and never a bad practice.  

a#snapshot
:marked
  #### _Snapshot_: the _no-observable_ alternative
  
  #### *Snapshot*（快照）：当不需要Observable时的替代品
  
  _This_ application won't re-use the `HeroDetailComponent`.
  The user always returns to the hero list to select another hero to view.
  There's no way to navigate from one hero detail to another hero detail
  without visiting the list component in between.
  Therefore, the router creates a new `HeroDetailComponent` instance every time.
  
  本应用不需要复用`HeroDetailComponent`。
    我们总会先返回英雄列表，再选择另一位英雄。
    所以，不存在从一个英雄详情导航到另一个而不用经过英雄列表的情况。
    这意味着我们每次都会得到一个全新的`HeroDetailComponent`实例。

  When you know for certain that a `HeroDetailComponent` instance will *never, never, ever*
  be re-used, you can simplify the code with the *snapshot*.
  
  假如我们很确定这个`HeroDetailComponent`组件的实例*永远、永远*不会被复用，那就可以使用*快照*来简化这段代码。

  The `route.snapshot` provides the initial value of the route parameters.
  You can access the parameters directly without subscribing or adding observable operators.
  It's much simpler to write and read:
  
  `route.snapshot`提供了路由参数的初始值。
  我们可以通过它来直接访问参数，而不用订阅或者添加Observable的操作符。
  这样在读写时就会更简单：

+makeExcerpt('src/app/heroes/hero-detail.component.2.ts (ngOnInit snapshot)', 'snapshot')

.l-sub-section

  :marked
    **Remember:** you only get the _initial_ value of the parameters with this technique.
    Stick with the observable `params` approach if there's even a chance that the router 
    could re-use the component.
    This sample stays with the observable `params` strategy just in case.

    **记住：**，用这种技巧，我们只得到了这些参数的_初始_值。
    如果有可能连续多次导航到此组件，那么就该用`params`可观察对象的方式。
    我们在这里选择使用`params`可观察对象策略，以防万一。

a#nav-to-list
:marked
  ### Navigating back to the list component

  ### 导航回列表组件

  The `HeroDetailComponent` has a "Back" button wired to its `gotoHeroes` method that navigates imperatively
  back to the `HeroListComponent`.

  `HeroDetailComponent`组件有一个“Back”按钮，关联到它的`gotoHeroes`方法，该方法会导航回`HeroListComponent`组件。

  The router `navigate` method takes the same one-item _link parameters array_
  that you can bind to a `[routerLink]` directive.
  It holds the _path to the `HeroListComponent`_:

  路由的`navigate`方法同样接受一个单条目的*链接参数数组*，我们也可以把它绑定到`[routerLink]`指令上。
  它保存着**到`HeroListComponent`组件的路径**：

+makeExcerpt('src/app/heroes/hero-detail.component.1.ts (excerpt)', 'gotoHeroes')

.l-main-section#optional-route-parameters
:marked
  ### Route Parameters: Required or optional?
  ### 路由参数：必须还是可选？

  Use [*route parameters*](#route-parameters) to specify a *required* parameter value *within* the route URL
  as you do when navigating to the `HeroDetailComponent` in order to view the hero with *id*15:
  
  如果想导航到`HeroDetailComponent`以对id为15的英雄进行查看并编辑，就要在路由的URL中使用[*路由参数*](#route-parameters)来指定*必要*参数值。
  
code-example(format="nocode").
  localhost:3000/hero/15

:marked
  You can also add *optional* information to a route request.
  For example, when returning to the heroes list from the hero detail view, 
  it would be nice if the viewed hero was preselected in the list.
  
  我们也能在路由请求中添加*可选*信息。
  比如，当从`HeroDetailComponent`返回英雄列表时，如果能自动选中刚刚查看过的英雄就好了。

figure.image-display
  img(src='/resources/images/devguide/router/selected-hero.png' alt="Selected hero")

:marked
  You'll implement this feature in a moment by including the viewed hero's `id` 
  in the URL as an optional parameter when returning from the `HeroDetailComponent`.

  如果我们能在从`HeroDetailComponent`返回时在URL中带上英雄Magneta的`id`，不就可以了吗？接下来我们就尝试实现这个场景。

  Optional information takes other forms. Search criteria are often loosely structured, e.g., `name='wind*'`.
  Multiple values are common&mdash;`after='12/31/2015' & before='1/1/2017'`&mdash;in no 
  particular order&mdash;`before='1/1/2017' & after='12/31/2015'`&mdash; in a 
  variety of formats&mdash;`during='currentYear'`.

  可选信息有很多种形式。搜索条件通常就不是严格结构化的，比如`name='wind*'`；有多个值也很常见，如`after='12/31/2015'&before='1/1/2017'`；
  而且顺序无关，如`before='1/1/2017'&after='12/31/2015'`，还可能有很多种变体格式，如`during='currentYear'`。

  These kinds of parameters don't fit easily in a URL *path*. Even if you could define a suitable URL token scheme,
  doing so greatly complicates the pattern matching required to translate an incoming URL to a named route.

  这么多种参数要放在URL的*路径*中可不容易。即使我们能制定出一个合适的URL方案，实现起来也太复杂了，得通过模式匹配才能把URL翻译成命名路由。

  Optional parameters are the ideal vehicle for conveying arbitrarily complex information during navigation.
  Optional parameters aren't involved in pattern matching and afford flexibility of expression.

  可选参数是在导航期间传送任意复杂信息的理想载体。
  可选参数不涉及到模式匹配并在表达上提供了巨大的灵活性。

  The router supports navigation with optional parameters as well as required route parameters.
  Define _optional_ parameters in a separate object _after_ you define the required route parameters.
  
  和必要参数一样，路由器也支持通过可选参数导航。
  我们在定义完必要参数之后，通过一个*独立的对象*来定义*可选参数*。

  In general, prefer a *required route parameter* when
  the value is mandatory (for example, if necessary to distinguish one route path from another);
  prefer an *optional parameter* when the value is optional, complex, and/or multivariate.
  
  通常，对于强制性的值（比如用于区分两个路由路径的）使用*必备参数*；当这个值是可选的、复杂的或多值的时，使用可选参数。

a#optionally-selecting
:marked
  ### Heroes list: optionally selecting a hero

  When navigating to the `HeroDetailComponent` you specified the _required_ `id` of the hero-to-edit in the
  *route parameter* and made it the second item of the [_link parameters array_](#link-parameters-array).

+makeExcerpt('src/app/heroes/hero-list.component.1.ts', 'link-parameters-array')

:marked
  The router embedded the `id` value in the navigation URL because you had defined it
  as a route parameter with an `:id` placeholder token in the route `path`:

  路由器在导航URL中内嵌了`id`的值，这是因为我们把它用一个`:id`占位符当做路由参数定义在了路由的`path`中：

+makeExcerpt('src/app/heroes/heroes-routing.module.ts', 'hero-detail-route')

:marked
  When the user clicks the back button, the `HeroDetailComponent` constructs another _link parameters array_
  which it uses to navigate back to the `HeroListComponent`.

  当用户点击后退按钮时，`HeroDetailComponent`构造了另一个*链接参数数组*，可以用它导航回`HeroListComponent`。

+makeExcerpt('src/app/heroes/hero-detail.component.1.ts', 'gotoHeroes')

:marked
  This array lacks a route parameter because you had no reason to send information to the `HeroListComponent`.

  该数组缺少一个路由参数，这是因为我们那时没有理由往`HeroListComponent`发送信息。

  Now you have a reason. You'd like to send the id of the current hero with the navigation request so that the
  `HeroListComponent` can highlight that hero in its list.
  This is a _nice-to-have_ feature; the list will display perfectly well without it.
  
  但现在有了。我们要在导航请求中同时发送当前英雄的id，以便`HeroListComponent`可以在列表中高亮这个英雄。
    这是一个*有更好，没有也无所谓*的特性，就算没有它，列表照样能显示得很完美。

  Send the `id` with an object that contains an _optional_ `id` parameter.
  For demonstration purposes, there's an extra junk parameter (`foo`) in the object that the `HeroListComponent` should ignore.
  Here's the revised navigation statement:

  我们传送一个包含*可选*`id`参数的对象。
  为了演示，我们还在对象中定义了一个没用的额外参数（`foo`），`HeroListComponent`应该忽略它。
  下面是修改过的导航语句：

+makeExcerpt('src/app/heroes/hero-detail.component.ts (go to heroes)', 'gotoHeroes')

:marked
  The application still works. Clicking "back" returns to the hero list view.

  该应用仍然能工作。点击“back”按钮返回英雄列表视图。

  Look at the browser address bar.
  
  注意浏览器的地址栏。

include ../../../_includes/_see-addr-bar

:marked
  It should look something like this, depending on where you run it:

  看起来应该是这样，不过也取决于你在哪里运行它：

code-example(language="bash").
  localhost:3000/heroes;id=15;foo=foo

:marked
  The `id` value appears in the URL as (`;id=15;foo=foo`), not in the URL path.
  The path for the "Heroes" route doesn't have an `:id` token.

  `id`的值像这样出现在URL中（`;id=15;foo=foo`），但不在URL的路径部分。
  “Heroes”路由的路径部分并没有定义`:id`。

  The optional route parameters are not separated by "?" and "&" as they would be in the URL query string.
  They are **separated by semicolons ";"**
  This is *matrix URL* notation &mdash; something you may not have seen before.

  可选的路由参数没有使用“？”和“&”符号分隔，因为它们将用在URL查询字符串中。
  它们是**用“;”分隔的**。
  这是*矩阵URL*标记法 —— 我们以前可能从未见过。

.l-sub-section
  :marked
    *Matrix URL* notation is an idea first introduced
    in a [1996 proposal](http://www.w3.org/DesignIssues/MatrixURIs.html) by the founder of the web, Tim Berners-Lee.

    *Matrix URL*写法首次提出是在[1996提案](http://www.w3.org/DesignIssues/MatrixURIs.html)中，提出者是Web的奠基人：Tim Berners-Lee。

    Although matrix notation never made it into the HTML standard, it is legal and
    it became popular among browser routing systems as a way to isolate parameters
    belonging to parent and child routes. The Router is such a system and provides
    support for the matrix notation across browsers.

    虽然Matrix写法未曾进入过HTML标准，但它是合法的。而且在浏览器的路由系统中，它作为从父路由和子路由中单独隔离出参数的方式而广受欢迎。Angular的路由器正是这样一个路由系统，并支持跨浏览器的Matrix写法。

    The syntax may seem strange to you but users are unlikely to notice or care
    as long as the URL can be emailed and pasted into a browser address bar
    as this one can.

    这种语法对我们来说可能有点奇怪，不过用户不会在意这一点，因为该URL可以正常的通过邮件发出去或粘贴到浏览器的地址栏中。

a#route-parameters-activated-route
:marked
  ### Route parameters in the *ActivatedRoute* service

  ### *ActivatedRoute*服务中的路由参数

  The list of heroes is unchanged. No hero row is highlighted.

  英雄列表仍没有改变，没有哪个英雄列被加亮显示。

.l-sub-section
  :marked
    The <live-example></live-example> *does* highlight the selected
    row because it demonstrates the final state of the application which includes the steps you're *about* to cover.
    At the moment this guide is describing the state of affairs *prior* to those steps.

    <live-example>在线例子</live-example>*高亮了*选中的行，因为它演示的是应用的最终状态，因此包含了我们*即将*示范的步骤。
    此刻，我们描述的仍是那些步骤*之前*的状态。
:marked
  The `HeroListComponent` isn't expecting any parameters at all and wouldn't know what to do with them.
  You can change that.

  `HeroListComponent`还完全不需要任何参数，也不知道该怎么处理它们。我们这就改变这一点。

  Previously, when navigating from the `HeroListComponent` to the `HeroDetailComponent`,
  you subscribed to the route params `Observable` and made it available to the `HeroDetailComponent`
  in the `ActivatedRoute` service. 
  You injected that service in the constructor of the `HeroDetailComponent`.

  以前，当从`HeroListComponent`导航到`HeroDetailComponent`时，我们通过`ActivatedRoute`服务订阅了路由参数这个`Observable`，并让它能用在`HeroDetailComponent`中。我们把该服务注入到了`HeroDetailComponent`的构造函数中。

  This time you'll be navigating in the opposite direction, from the `HeroDetailComponent` to the `HeroListComponent`.

  这次，我们要进行反向导航，从`HeroDetailComponent`到`HeroListComponent`。

  First you extend the router import statement to include the `ActivatedRoute` service symbol:

  首先，我们扩展该路由的导入语句，以包含进`ActivatedRoute`服务的类；

+makeExcerpt('src/app/heroes/hero-list.component.ts (import)', 'import-router')

:marked
  Import the `switchMap` operator to perform an operation on the `Observable` of route parameters.

  我们将导入`switchMap`操作符，在路由参数的`Observable`对象上执行操作。

+makeExcerpt('src/app/heroes/hero-list.component.ts (rxjs imports)', 'rxjs-imports')

:marked
  Then you inject the `ActivatedRoute` in the `HeroListComponent` constructor.

  接着，我们注入`ActivatedRoute`到`HeroListComponent`的构造函数中。

+makeExcerpt('src/app/heroes/hero-list.component.ts (constructor and ngOnInit)', 'ctor')

:marked
  The `ActivatedRoute.params` property is an `Observable` of route parameters. The `params` emits new `id` values
  when the user navigates to the component. In `ngOnInit` you subscribe to those values, set the `selectedId`,
  and get the heroes.

  ActivatedRoute.params属性是一个路由参数的可观察对象。当用户导航到这个组件时，params会发射一个新的id值。
  在ngOnInit中，我们订阅了这些值，设置到selectedId，并获取英雄数据。

.l-sub-section
  :marked
    All route/query parameters are strings.
    The (+) in front of the `params['id']` expression is a JavaScript trick to convert the string to an integer.

    所有的路由参数或查询参数都是字符串。
    `params['id']`表达式前面的加号（+）是一个JavaScript的小技巧，用来把字符串转换成整数。

:marked
  Add an `isSelected` method that returns `true` when a hero's `id` matches the selected `id`.

  我们添加了一个`isSelected`方法，当英雄的id和选中的id匹配时，它返回真值。

+makeExcerpt('src/app/heroes/hero-list.component.ts', 'isSelected')

:marked
  Finally, update the template with a [class binding](template-syntax.html#class-binding) to that `isSelected` method.
  The binding adds the `selected` CSS class when the method returns `true` and removes it when `false`.
  Look for it within the repeated `<li>` tag as shown here:

  最后，我们用[CSS类绑定](template-syntax.html#class-binding)更新模板，把它绑定到`isSelected`方法上。
  如果该方法返回`true`，此绑定就会添加CSS类`selected`，否则就移除它。
  在`<li>`标记中找到它，就像这样：

+makeExcerpt('src/app/heroes/hero-list.component.ts', 'template')

:marked
  When the user navigates from the heroes list to the "Magneta" hero and back, "Magneta" appears selected:

  当用户从英雄列表导航到英雄“Magneta”并返回时，“Magneta”看起来是选中的：

figure.image-display
  img(src='/resources/images/devguide/router/selected-hero.png' alt="Selected List" )
:marked
  The optional `foo` route parameter is harmless and continues to be ignored.

  这儿可选的`foo`路由参数人畜无害，并继续被忽略。

a#route-animation

:marked
  ### Adding animations to the routed component
  
  ### 为路由组件添加动画
  
  The heroes feature module is almost complete, but what is a feature without some smooth transitions?
  
  这个“英雄”特性模块就要完成了，但这个特性还没有平滑的转场效果。

  This section shows you how to add some [animations](../guide/animations.html) 
  to the `HeroDetailComponent`.
  
  在这一节，我们将为*英雄详情*组件添加一些[动画](../guide/animations.html)。

  First import `BrowserAnimationsModule`:
  
  首先导入`BrowserAnimationsModule`：
  
+makeExcerpt('src/app/app.module.ts', 'animations-module', 'src/app/app.module.ts (@NgModule imports excerpt)')

:marked
  Create an `animations.ts` file in the root `src/app/` folder. The contents look like this:
  
  在根目录`src/app/`下创建一个`animations.ts`。内容如下：
  
+makeExcerpt('src/app/animations.ts', '', 'src/app/animations.ts')
:marked
  This file does the following:

  * Imports the animation symbols that build the animation triggers, control state, and manage transitions between states. 

  * Exports a constant named `slideInDownAnimation` set to an animation trigger named *`routeAnimation`*; 
  animated components will refer to this name.

  * Specifies the _wildcard state_ , `*`, that matches any animation state that the route component is in.
  
  * Defines two *transitions*, one to ease the component in from the left of the screen as it enters the application view (`:enter`), 
  the other to animate the component down as it leaves the application view (`:leave`).

  You could create more triggers with different transitions for other route components. This trigger is sufficient for the current milestone.

:marked
  Back in the `HeroDetailComponent`, import the `slideInDownAnimation` from `'./animations.ts`.
  Add the `HostBinding` decorator  to the imports from `@angular/core`; you'll need it in a moment.

  Add an `animations` array to the `@Component` metadata's that contains the `slideInDownAnimation`.

  Then add three `@HostBinding` properties to the class to set the animation and styles for the route component's element.
+makeExcerpt('src/app/heroes/hero-detail.component.ts (host bindings)', 'host-bindings')
:marked
  The `'@routeAnimation'` passed to the first `@HostBinding` matches 
  the name of the `slideInDownAnimation` _trigger_, `routeAnimation`.
  Set the `routeAnimation` property to `true` because you only care about the `:enter` and `:leave` states.

  The other two `@HostBinding` properties style the display and position of the component.

  The `HeroDetailComponent` will ease in from the left when routed to and will slide down when navigating away.

.l-sub-section
  :marked
    Applying route animations to individual components works for a simple demo, but in a real life app,
    it is better to animate routes based on _route paths_.

    由特性模块提供的路由将会被路由器和它们导入的模块提供的路由组合在一起。这让我们可以继续定义特性路由，而不用修改主路由配置。

a#milestone-3-wrap-up
:marked
  ### Milestone 3 wrap up
  ### 里程碑#3的总结

  You've learned how to do the following:
  
  我们学到了如何：

  * Organize the app into *feature areas*.
      
      把应用组织成*特性区*
      
  * Navigate imperatively from one component to another.
  
      命令式的从一个组件导航到另一个
      
  * Pass information along in route parameters and subscribe to them in the component.
  
      *通过路由参数传递信息，并在组件中订阅它们
      
  * Import the feature area NgModule into the `AppModule`.
  
      把这个特性分区模块导入根模块`AppModule`
      
  * Apply animations to the route component.

      把动画应用到路由组件上

  After these changes, the folder structure looks like this:

  做完这些修改之后，目录结构看起来就像这样：

.filetree
  .file router-sample
  .children
    .file src
    .children
      .file app
      .children
        .file heroes
        .children
          .file hero-detail.component.ts
          .file hero-list.component.ts
          .file hero.service.ts
          .file heroes.module.ts
          .file heroes-routing.module.ts
        .file app.component.ts
        .file app.module.ts
        .file app-routing.module.ts
        .file crisis-list.component.ts
      .file main.ts
      .file index.html
      .file styles.css
      .file tsconfig.json
    .file node_modules ...
    .file package.json
      
:marked
  Here are the relevant files for this version of the sample application.

  这里是当前版本的范例程序相关文件。

+makeTabs(
  `router/ts/src/app/app.component.1.ts,
   router/ts/src/app/app.module.3.ts,
   router/ts/src/app/app-routing.module.2.ts,
   router/ts/src/app/heroes/hero-list.component.ts,
   router/ts/src/app/heroes/hero-detail.component.ts,
   router/ts/src/app/heroes/hero.service.ts,
   router/ts/src/app/heroes/heroes.module.ts,
   router/ts/src/app/heroes/heroes-routing.module.ts`,
   '',
  `app.component.ts,
  app.module.ts,
  app-routing.module.ts,
  hero-list.component.ts,
  hero-detail.component.ts,
  hero.service.ts,
  heroes.module.ts,
  heroes-routing.module.ts`)

a#milestone-4
.l-main-section
:marked
  ## Milestone 4: Crisis center feature
  
  ## 里程碑#4：危机中心

  It's time to add real features to the app's current placeholder crisis center.
  
  Begin by imitating the heroes feature:
  
  * Delete the placeholder crisis center file.
  * Create an `app/crisis-center` folder.
  * Copy the files from `app/heroes` into the new crisis center folder.
  * In the new files, change every mention of "hero" to "crisis", and "heroes" to "crises".
  
  You'll turn the `CrisisService` into a purveyor of mock crises instead of mock heroes:

+makeExcerpt('src/app/crisis-center/crisis.service.ts', 'mock-crises')

:marked
  The resulting crisis center is a foundation for introducing a new concept&mdash;**child routing**.
  You can leave *Heroes* in its current state as a contrast with the *Crisis Center*
  and decide later if the differences are worthwhile.

.alert.is-helpful
  :marked
    In keeping with the
    <a href="https://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html" target="_blank" title="Separation of Concerns">*Separation of Concerns* principle</a>,
    changes to the *Crisis Center* won't affect the `AppModule` or
    any other feature's component.
a#crisis-child-routes
:marked
  ### A crisis center with child routes

  This section shows you how to organize the crisis center 
  to conform to the following recommended pattern for Angular applications:

  * Each feature area resides in its own folder. 
  * Each feature has its own Angular feature module.
  * Each area has its own area root component.
  * Each area root component has its own router outlet and child routes.
  * Feature area routes rarely (if ever) cross with routes of other features.

  If your app had many feature areas, the app component trees might look like this:

  如果我们有更多特性区，它们的组件树看起来是这样的：

figure.image-display
  img(src='/resources/images/devguide/router/component-tree.png' alt="Component Tree" )

a#child-routing-component
:marked
  ### Child routing component

  ### 子路由组件

  Add the following `crisis-center.component.ts` to the `crisis-center` folder:

  往`crisis-center`目录下添加下列`crisis-center.component.ts`文件：

+makeExcerpt('src/app/crisis-center/crisis-center.component.ts (minus imports)', 'minus-imports')

:marked
  The `CrisisCenterComponent` has the following in common with the `AppComponent`:
  
  * It is the *root* of the crisis center area,
  just as `AppComponent` is the root of the entire application.
  * It is a *shell* for the crisis management feature area,
  just as the `AppComponent` is a shell to manage the high-level workflow.

  Like most shells, the `CrisisCenterComponent` class is very simple, simpler even than `AppComponent`:
  it has no business logic, and its template has no links, just a title and 
  `<router-outlet>` for the crisis center child views.

  Unlike `AppComponent`, and most other components, it _lacks a selector_.
  It doesn't _need_ one since you don't *embed* this component in a parent template,
  instead you use the router to *navigate* to it.

a#child-route-config
:marked
  ### Child route configuration

  The `CrisisCenterComponent` is a *routing component* like the `AppComponent`.
  It has its own `RouterOutlet` and its own child routes.

  `CrisisCenterComponent`是一个像`AppComponent`一样的*路由组件*。
  它有自己的`RouterOutlet`和自己的子路由。

  Add the following `crisis-center-home.component.ts` to the `crisis-center` folder.

  把下面的`crisis-center-home.component.ts`文件添加到`crisis-center`目录中。

+makeExcerpt('src/app/crisis-center/crisis-center-home.component.ts (minus imports)', 'minus-imports')

:marked
  Create a `crisis-center-routing.module.ts` file as you did the `heroes-routing.module.ts` file.
  This time, you define **child routes** *within* the parent `crisis-center` route.

  像`heroes-routing.module.ts`文件一样，我们也创建一个`crisis-center-routing.module.ts`。
  但这次，我们要把**子路由**定义在父路由`crisis-center`中。

+makeExcerpt('src/app/crisis-center/crisis-center-routing.module.1.ts (Routes)', 'routes')

:marked
  Notice that the parent `crisis-center` route has a `children` property
  with a single route containing the `CrisisListComponent`. The `CrisisListComponent` route
  also has a `children` array with two routes.

  注意，父路由`crisis-center`有一个`children`属性，它有一个包含`CrisisListComponent`的路由。
  `CrisisListModule`路由还有一个带两个路由的`children`数组。

  These two routes navigate to the crisis center child components,
  `CrisisCenterHomeComponent` and `CrisisDetailComponent`, respectively.

  这两个路由导航到了*危机中心*的两个子组件：`CrisisCenterHomeComponent`和`CrisisDetailComponent`。

  There are *important differences* in the way the router treats these _child routes_.

  对这些路由的处理中有一些*重要的不同*。

  The router displays the components of these routes in the `RouterOutlet`
  of the `CrisisCenterComponent`, not in the `RouterOutlet` of the `AppComponent` shell.

  路由器会把这些路由对应的组件放在`CrisisCenterComponent`的`RouterOutlet`中，而不是`AppComponent`壳组件中的。

  The `CrisisListComponent` contains the crisis list and a `RouterOutlet` to
  display the `Crisis Center Home` and `Crisis Detail` route components.

  `CrisisListComponent`包含危机列表和一个`RouterOutlet`，用以显示`Crisis Center Home`和`Crisis Detail`这两个路由组件。

  The `Crisis Detail` route is a child of the `Crisis List`. Since the router [reuses components](#reuse)
  by default, the `Crisis Detail` component will be re-used as you select different crises.

  `Crisis Detail`路由是`Crisis List`的子路由。由于路由器默认会[复用组件](#reuse)，因此当我们选择了另一个危机时，`CrisisDetailComponent`会被复用。  
  
  In contrast, back in the `Hero Detail` route, the component was recreated each time you selected a different hero.

  作为对比，回到`Hero Detail`路由时，每当我们选择了不同的英雄时，该组件都会被重新创建。

  At the top level, paths that begin with `/` refer to the root of the application.
  But child routes *extend* the path of the parent route.
  With each step down the route tree,
  you add a slash followed by the route path, unless the path is _empty_.
  
  在顶级，以`/`开头的路径指向的总是应用的根。
  但这里是子路由。
  它们是在父路由路径的基础上做出的扩展。
  在路由树中每深入一步，我们就会在该路由的路径上添加一个斜线`/`（除非该路由的路径是*空的*）。

  Apply that logic to navigation within the crisis center for which the parent path is `/crisis-center`.

  * To navigate to the `CrisisCenterHomeComponent`, the full URL is `/crisis-center` (`/crisis-center` + `''` + `''`).
  
      要导航到`CrisisCenterHomeComponent`，完整的URL是`/crisis-center` (`/crisis-center` + `''` + `''`)。

  * To navigate to the `CrisisDetailComponent` for a crisis with `id=2`, the full URL is
  `/crisis-center/2` (`/crisis-center` + `''` +  `'/2'`).
  
      要导航到`CrisisDetailComponent`以展示`id=2`的危机，完整的URL是`/crisis-center/2` (`/crisis-center` + `''` + `'/2'`)。

  The absolute URL for the latter example, including the `localhost` origin, is

  本例子中包含站点部分的绝对URL，就是：
  
code-example.
  localhost:3000/crisis-center/2

:marked
  Here's the complete `crisis-center-routing.module.ts` file with its imports.

  这里是完整的`crisis-center.routing.ts`及其导入语句。

+makeExcerpt('src/app/crisis-center/crisis-center-routing.module.1.ts', '')

a#import-crisis-module 
:marked
  ### Import crisis center module into the *AppModule* routes

  As with the `HeroesModule`, you must add the `CrisisCenterModule` to the `imports` array of the `AppModule` 
  _before_ the `AppRoutingModule`:
  
  就像`HeroesModule`模块中一样，我们必须把`CrisisCenterModule`添加到`AppModule`的`imports`数组中，就在`AppRoutingModule`前面：

+makeExcerpt('src/app/app.module.4.ts (import CrisisCenterModule)', 'crisis-center-module')

:marked
  Remove the initial crisis center route from the `app-routing.module.ts`. 
  The feature routes are now provided by the `HeroesModule` and the `CrisisCenter` modules. 
  
  The `app-routing.module.ts` file retains the top-level application routes such as the default and wildcard routes.

  我们还从`app.routing.ts`中移除了危机中心的初始路由。我们的路由现在是由`HeroesModule`和`CrisisCenter`特性模块提供的。
  我们将保持`app.routing.ts`文件中只有通用路由，本章稍后会讲解它。

+makeExcerpt('src/app/app-routing.module.3.ts (v3)')

.l-main-section
a#relative-navigation
:marked
  ### Relative navigation
  
  ### 相对导航

  While building out the crisis center feature, you navigated to the
  crisis detail route using an **absolute path** that begins with a _slash_.

  The router matches such _absolute_ paths to routes starting from the top of the route configuration. 

  You could continue to use absolute paths like this to navigate inside the *Crisis Center*
  feature, but that pins the links to the parent routing structure. 
  If you changed the parent `/crisis-center` path, you would have to change the link parameters array.

  You can free the links from this dependency by defining paths that are **relative** to the current URL segment.
  Navigation _within_ the feature area remains intact even if you change the parent route path to the feature.

  Here's an example:

.l-sub-section
  :marked
    The router supports directory-like syntax in a _link parameters list_ to help guide route name lookup:

    `./` or `no leading slash` is relative to the current level.

    `../` to go up one level in the route path.

    You can combine relative navigation syntax with an ancestor path. 
    If you must navigate to a sibling route, you could use the `../<sibling>` convention to go up
    one level, then over and down the sibling route path.

:marked
  To navigate a relative path with the `Router.navigate` method, you must supply the `ActivatedRoute`
  to give the router knowledge of where you are in the current route tree. 
  
  After the _link parameters array_, add an object with a `relativeTo` property set to the `ActivatedRoute`.
  The router then calculates the target URL based on the active route's location.

  “重定向（redirect）路由”需要一个`pathMatch`属性来告诉路由器如何把URL和路由中的路径进行匹配。
  本应用中，路由器应该只有在*完整的URL*匹配`''`时才选择指向`CrisisListComponent`的路由，因此，我们把`pathMatch`的值设置为`'full'`。

.l-sub-section

  :marked
    **Always** specify the complete _absolute_ path when calling router's `navigateByUrl` method.

a#nav-to-crisis
:marked
  ### Navigate to crisis detail with a relative URL

  Update the *Crisis List* `onSelect` method to use relative navigation so you don't have
  to start from the top of the route configuration.

  You've already injected the `ActivatedRoute` that you need to compose the relative navigation path.
+makeExcerpt('src/app/crisis-center/crisis-list.component.ts (constructor)', 'ctor')

:marked
  When you visit the *Crisis Center*, the ancestor path is `/crisis-center`, 
  so you only need to add the `id` of the *Crisis Center* to the existing path. 

+makeExcerpt('src/app/crisis-center/crisis-list.component.ts (relative navigation)', 'onSelect')

:marked
  If you were using a `RouterLink` to navigate instead of the `Router` service, you'd use the _same_
  link parameters array, but you wouldn't provide the object with the `relativeTo` property. 
  The `ActivatedRoute` is implicit in a `RouterLink` directive.

+makeExcerpt('src/app/crisis-center/crisis-list.component.1.ts (relative routerLink)', 'relative-navigation-router-link')

:marked
  Update the `gotoCrises` method of the `CrisisDetailComponent` to navigate back to the *Crisis Center* list using relative path navigation.

+makeExcerpt('src/app/crisis-center/crisis-detail.component.ts (relative navigation)', 'gotoCrises-navigate')
:marked
  Notice that the path goes up a level using the `../` syntax.
  If the current crisis `id` is `3`, the resulting path back to the crisis list is  `/crisis-center/;id=3;foo=foo`.

a#named-outlets
.l-main-section
:marked
  ### Displaying multiple routes in named outlets

  You decide to give users a way to contact the crisis center.
  When a user clicks a "Contact" button, you want to display a message in a popup view. 
  
  The popup should stay open, even when switching between pages in the application, until the user closes it 
  by sending the message or canceling. 
  Clearly you can't put the popup in the same outlet as the other pages.

  Until now, you've defined a single outlet and you've nested child routes 
  under that outlet to group routes together.
  The router only supports one primary _unnamed_ outlet per template.
  
  A template can also have any number of _named_ outlets.
  Each named outlet has its own set of routes with their own components.
  Multiple outlets can be displaying different content, determined by different routes, all at the same time.

  Add an outlet named "popup" in the `AppComponent`, directly below the unnamed outlet.

+makeExcerpt('src/app/app.component.4.ts', 'outlets')

:marked
  That's where a popup will go, once you learn how to route a popup component to it.

a#secondary-routes
:marked
  #### Secondary routes

  Named outlets are the targets of  _secondary routes_.
  
  Secondary routes look like primary routes and you configure them the same way.
  They differ in a few key respects. 

  * They are independent of each other.
  * They work in combination with other routes. 
  * They are displayed in named outlets.

  Create a new component named `ComposeMessageComponent` in `src/app/compose-message.component.ts`.
  It displays a simple form with a header, an input box for the message,
  and two buttons, "Send" and "Cancel".

figure.image-display
  img(src='/resources/images/devguide/router/contact-popup.png' alt="Contact popup" width="250")

:marked
  Here's the component and its template:

+makeTabs(
   `router/ts/src/app/compose-message.component.ts,
   router/ts/src/app/compose-message.component.html`,
    null,
   `src/app/compose-message.component.ts,
   src/app/compose-message.component.html`)

:marked
  It looks about the same as any other component you've seen in this guide.
  There are two noteworthy differences.

  Note that the `send()` method simulates latency by waiting a second before "sending" the message and closing the popup.
  
  The `closePopup()` method closes the popup view by navigating to the popup outlet with a `null`.
  That's a peculiarity covered [below](#clear-secondary-routes).

  As with other application components, you add the `ComposeMessageComponent` to the `declarations` of an `NgModule`.
  Do so in the `AppModule`.

a#add-secondary-route
:marked
  #### Add a secondary route
  
  Open the `AppRoutingModule` and add a new `compose` route to the `appRoutes`.
+makeExcerpt('src/app/app-routing.module.3.ts (compose route)', 'compose')

:marked
  The `path` and `component` properties should be familiar.
  There's a new property, `outlet`, set to `'popup'`.
  This route now targets the popup outlet and the `ComposeMessageComponent` will display there. 

  The user needs a way to open the popup.
  Open the `AppComponent` and add a "Contact" link.
+makeExcerpt('src/app/app.component.4.ts', 'contact-link')
:marked
  Although the `compose` route is pinned to the "popup" outlet, that's not sufficient for wiring the route to a `RouterLink` directive.
  You have to specify the named outlet in a _link parameters array_ and bind it to the `RouterLink` with a property binding.

  The _link parameters array_ contains an object with a single `outlets` property whose value
  is another object keyed by one (or more) outlet names.
  In this case there is only the "popup" outlet property and its value is another _link parameters array_ that specifies the `compose` route.

  You are in effect saying, _when the user clicks this link, display the component associated with the `compose` route in the `popup` outlet_.

.l-sub-section
  :marked
    This `outlets` object within an outer object was completely unnecessary
    when there was only one route and one _unnamed_ outlet to think about.

    The router assumed that your route specification targeted the _unnamed_ primary outlet
    and created these objects for you.

    Routing to a named outlet has revealed a previously hidden router truth: 
    you can target multiple outlets with multiple routes in the same `RouterLink` directive.

    You're not actually doing that here. 
    But to target a named outlet, you must use the richer, more verbose syntax.

a#secondary-route-navigation
:marked
  #### Secondary route navigation: merging routes during navigation
  Navigate to the _Crisis Center_ and click "Contact".
  you should see something like the following URL in the browser address bar.

code-example.
    http://.../crisis-center(popup:compose)

:marked
  The interesting part of the URL follows the `...`:

  * The `crisis-center` is the primary navigation. 
  * Parentheses surround the secondary route.
  * The secondary route consists of an outlet name (`popup`), a `colon` separator, and the secondary route path (`compose`).

  Click the _Heroes_ link and look at the URL again.

code-example.
    http://.../heroes(popup:compose)
:marked
  The primary navigation part has changed; the secondary route is the same.

  The router is keeping track of two separate branches in a navigation tree and generating a representation of that tree in the URL.

  You can add many more outlets and routes, at the top level and in nested levels, creating a navigation tree with many branches.
  The router will generate the URL to go with it. 
  
  You can tell the router to navigate an entire tree at once by filling out the `outlets` object mentioned above.
  Then pass that object inside a _link parameters array_  to the `router.navigate` method.

  Experiment with these possibilities at your leisure.


a#clear-secondary-routes
:marked
  #### Clearing secondary routes
  As you've learned, a component in an outlet persists until you navigate away to a new component. 
  Secondary outlets are no different in this regard.

  Each secondary outlet has its own navigation, independent of the navigation driving the primary outlet.
  Changing a current route that displays in the primary outlet has no effect on the popup outlet.
  That's why the popup stays visible as you navigate among the crises and heroes.

  Clicking the "send" or "cancel" buttons _does_ clear the popup view.
  To see how, look at the `closePopup()` method again:
+makeExcerpt('src/app/compose-message.component.ts (closePopup)', 'closePopup')

:marked
  It navigates imperatively with the `Router.navigate()` method, passing in a [link parameters array](#link-parameters-array).
  
  Like the array bound to the _Contact_ `RouterLink` in the `AppComponent`,
  this one includes an object with an `outlets` property.
  The `outlets` property value is another object with outlet names for keys.
  The only named outlet is `'popup'`.

  This time, the value of `'popup'` is `null`. That's not a route, but it is a legitimate value.
  Setting the popup `RouterOutlet` to `null` clears the outlet and removes 
  the secondary popup route from the current URL.

.l-main-section#guards
:marked
  ## Milestone 5: Route guards
  
  ## 里程碑5：路由守卫
  

  At the moment, *any* user can navigate *anywhere* in the application *anytime*.
  That's not always the right thing to do.

  现在，*任何用户*都能在*任何时候*导航到*任何地方*。
  但有时候这样是不对的。

  * Perhaps the user is not authorized to navigate to the target component.

    该用户可能无权导航到目标组件。

  * Maybe the user must login (*authenticate*) first.

    可能用户得先登录（认证）。

  * Maybe you should fetch some data before you display the target component.

    在显示目标组件前，我们可能得先获取某些数据。

  * You might want to save pending changes before leaving a component.

    在离开组件前，我们可能要先保存修改。

  * You might ask the user if it's OK to discard pending changes rather than save them.

    我们可能要询问用户：你是否要放弃本次更改，而不用保存它们？

  You can add _guards_ to the route configuration to handle these scenarios.

  我们可以往路由配置中添加***守卫***，来处理这些场景。

  A guard's return value controls the router's behavior:

  守卫返回一个值，以控制路由器的行为：

  * If it returns `true`, the navigation process continues.

    如果它返回`true`，导航过程会继续

  * If it returns `false`, the navigation process stops and the user stays put.

    如果它返回`false`，导航过程会终止，且用户会留在原地。

.l-sub-section

  :marked
    The guard can also tell the router to navigate elsewhere, effectively canceling the current navigation.

    守卫还可以告诉路由器导航到别处，这样也取消当前的导航。

:marked
  The guard *might* return its boolean answer synchronously.
  But in many cases, the guard can't produce an answer synchronously.
  The guard could ask the user a question, save changes to the server, or fetch fresh data.
  These are all asynchronous operations.

  守卫*可以*用同步的方式返回一个布尔值。但在很多情况下，守卫无法用同步的方式给出答案。
  守卫可能会向用户问一个问题、把更改保存到服务器，或者获取新数据，而这些都是异步操作。

  Accordingly, a routing guard can return an `Observable<boolean>` or a `Promise<boolean>` and the
  router will wait for the observable to resolve to `true` or `false`.

  因此，路由的守卫可以返回一个`Observable<boolean>`或`Promise<boolean>`，并且路由器会等待这个可观察对象被解析为`true`或`false`。

  The router supports multiple kinds of guards:

  路由器支持多种守卫：

  1. [`CanActivate`](../api/router/index/CanActivate-interface.html) to mediate navigation *to* a route.

     用[`CanActivate`](../api/router/index/CanActivate-interface.html)来处理导航*到*某路由的情况。

  2. [`CanActivateChild()`](../api/router/index/CanActivateChild-interface.html) to mediate navigation *to* a child route.

     用[`CanActivateChild`](../api/router/index/CanActivateChild-interface.html)处理导航*到*子路由的情况。

  3. [`CanDeactivate`](../api/router/index/CanDeactivate-interface.html) to mediate navigation *away* from the current route.

     用[`CanDeactivate`](../api/router/index/CanDeactivate-interface.html)来处理从当前路由*离开*的情况。

  4. [`Resolve`](../api/router/index/Resolve-interface.html) to perform route data retrieval *before* route activation.

     用[`Resolve`](../api/router/index/Resolve-interface.html)在路由激活*之前*获取路由数据。

  5. [`CanLoad`](../api/router/index/CanLoad-interface.html) to mediate navigation *to* a feature module loaded _asynchronously_.

     用[`CanLoad`](../api/router/index/CanLoad-interface.html)来处理*异步*导航到某特性模块的情况。

:marked
  You can have multiple guards at every level of a routing hierarchy.
  The router checks the `CanDeactivate()` and `CanActivateChild()` guards first, from the deepest child route to the top.
  Then it checks the `CanActivate()` guards from the top down to the deepest child route. If the feature module
  is loaded asynchronously, the `CanLoad()` guard is checked before the module is loaded.
  If _any_ guard returns false, pending guards that have not completed will be canceled,
  and the entire navigation is canceled.

  在分层路由的每个级别上，我们都可以设置多个守卫。
  路由器会先按照从最深的子路由由下往上检查的顺序来检查`CanDeactivate()`和`CanActivateChild()`守卫。
  然后它会按照从上到下的顺序检查`CanActivate()`和`CanActivateChild()`守卫。
  如果特性模块是异步加载的，在加载它之前还会检查`CanLoad()`守卫。
  如果*任何*一个守卫返回`false`，其它尚未完成的守卫会被取消，这样整个导航就被取消了。

  There are several examples over the next few sections.

  我们会在接下来的小节中看到一些例子。

a#can-activate-guard
:marked
  ### _CanActivate_: requiring authentication

  ### *CanActivate*: 要求认证

  Applications often restrict access to a feature area based on who the user is.
  You could permit access only to authenticated users or to users with a specific role.
  You might block or limit access until the user's account is activated.

  应用程序通常会根据访问者来决定是否授予某个特性区的访问权。
  我们可以只对已认证过的用户或具有特定角色的用户授予访问权，还可以阻止或限制用户访问权，直到用户账户激活为止。

  The `CanActivate` guard is the tool to manage these navigation business rules.

  `CanActivate`守卫是一个管理这些导航类业务规则的工具。

  #### Add an admin feature module
  
  #### 添加一个“管理”特性模块
  

  In this next section, you'll extend the crisis center with some new *administrative* features.
  Those features aren't defined yet. 
  But you can start by adding a new feature module named `AdminModule`.

  Create an `admin` folder with a feature module file, a routing configuration file, and supporting components.

  The admin feature file structure looks like this:

  管理特性区的文件是这样的：

.filetree
  .file src/app/admin
  .children
    .file admin-dashboard.component.ts
    .file admin.component.ts
    .file admin.module.ts
    .file admin-routing.module.ts
    .file manage-crises.component.ts
    .file manage-heroes.component.ts

:marked
  The admin feature module contains the `AdminComponent` used for routing within the
  feature module, a dashboard route and two unfinished components to manage crises and heroes.

  管理特性模块包含`AdminComponent`，它用于在特性模块内的仪表盘路由以及两个尚未完成的用于管理危机和英雄的组件之间进行路由。

+makeTabs(
   `router/ts/src/app/admin/admin-dashboard.component.1.ts,
   router/ts/src/app/admin/admin.component.ts,
   router/ts/src/app/admin/admin.module.ts,
   router/ts/src/app/admin/manage-crises.component.ts,
   router/ts/src/app/admin/manage-heroes.component.ts
  `,
  null,
   `src/app/admin/admin-dashboard.component.ts,
   src/app/admin/admin.component.ts,
   src/app/admin/admin.module.ts,
   src/app/admin/manage-crises.component.ts,
   src/app/admin/manage-heroes.component.ts
  `)

.l-sub-section
  :marked
    Since the admin dashboard `RouterLink` is an empty path route in the `AdminComponent`, it
    is considered a match to any route within the admin feature area. 
    You only want the `Dashboard` link to be active when the user visits that route. 
    Adding an additional binding to the `Dashboard` routerLink,
    `[routerLinkActiveOptions]="{ exact: true }"`, marks the `./` link as active when
    the user navigates to the `/admin` URL and not when navigating to any of the child routes.

    由于`AdminModule`中`AdminComponent`中的`RouterLink`是一个空路径的路由，所以它会匹配到管理特性区的任何路由。但我们只有在访问`Dashboard`路由时才希望该链接被激活。所以我们往`Dashboard`这个routerLink上添加了另一个绑定`[routerLinkActiveOptions]="{ exact: true }"`，这样就只有当我们导航到`/admin`这个URL时才会激活它，而不会在导航到它的某个子路由时。

:marked
  The initial admin routing configuration:

  我们的初始管理路由配置如下：

+makeExcerpt('src/app/admin/admin-routing.module.1.ts (admin routing)', 'admin-routes')

a#component-less-route 
:marked
  ### Component-less route: grouping routes without a component
  
  ### 无组件路由: 不借助组件对路由进行分组
  
  Looking at the child route under the `AdminComponent`, there is a `path` and a `children`
  property but it's not using a `component`. 
  You haven't made a mistake in the configuration. 
  You've defined a _component-less_ route.
  
  来看`AdminComponent`下的子路由，我们有一个带**path**和**children**的子路由，但它没有使用**component**。这并不是配置中的失误，而是在使用**无组件**路由。

  The goal is to group the `Crisis Center` management routes under the `admin` path.
  You don't need a component to do it. 
  A _component-less_ route makes it easier to [guard child routes](#can-activate-child-guard).

  我们的目标是对`admin`路径下的`危机中心`管理类路由进行分组，但并不需要另一个仅用来分组路由的组件。
  一个*无组件*的路由就能让我们轻松的[守卫子路由](#can-activate-child-guard)。

:marked
  Next, import the `AdminModule` into `app.module.ts` and add it to the `imports` array
  to register the admin routes.

  接下来，我们把`AdminModule`导入到`app.module.ts`中，并把它加入`imports`数组中来注册这些管理类路由。

+makeExcerpt('src/app/app.module.4.ts (admin module)', 'admin-module')

:marked
  Add an "Admin" link to the `AppComponent` shell so that users can get to this feature.

  然后我们往壳组件`AppComponent`中添加一个链接，让用户能点击它，以访问该特性。

+makeExcerpt('src/app/app.component.5.ts', 'template')

a#guard-admin-feature
:marked
  #### Guard the admin feature
  #### 守护“管理特性”区  

  Currently every route within the *Crisis Center* is open to everyone.
  The new *admin* feature should be accessible only to authenticated users.

  现在“危机中心”的每个路由都是对所有人开放的。这些新的*管理特性*应该只能被已登录用户访问。

  You could hide the link until the user logs in. But that's tricky and difficult to maintain.

  我们可以在用户登录之前隐藏这些链接，但这样会有点复杂并难以维护。

  Instead you'll write a `CanActivate()` guard to redirect anonymous users to the 
  login page when they try to enter the admin area.

  我们换种方式：写一个`CanActivate()`守卫，当匿名用户尝试访问管理组件时，把它/她重定向到登录页。

  This is a general purpose guard&mdash;you can imagine other features 
  that require authenticated users&mdash;so you create an 
  `auth-guard.service.ts` in the application root folder.

  这是一种具有通用性的守护目标（通常会有其它特性需要登录用户才能访问），所以我们在应用的根目录下创建一个`auth-guard.ts`文件。

  At the moment you're interested in seeing how guards work so the first version does nothing useful.
  It simply logs to console and `returns` true immediately, allowing navigation to proceed:

  此刻，我们的兴趣在于看看守卫是如何工作的，所以我们第一个版本没做什么有用的事情。它只是往控制台写日志，并且立即返回`true`，让导航继续：

+makeExcerpt('src/app/auth-guard.service.1.ts')

:marked
  Next, open `admin-routing.module.ts `, import the `AuthGuard` class, and
  update the admin route with a `CanActivate()` guard property that references it:

  接下来，打开`crisis-center.routes.ts`，导入`AuthGuard`类，修改管理路由并通过`CanActivate()`守卫来引用`AuthGuard`：

+makeExcerpt('src/app/admin/admin-routing.module.2.ts (guarded admin route)', 'admin-route')

:marked
  The admin feature is now protected by the guard, albeit protected poorly.

  我们的管理特性区现在受此守卫保护了，不过这样的保护还不够。

a#teach-auth
:marked
  #### Teach *AuthGuard* to authenticate

  #### 教*AuthGuard*进行认证

  Make the `AuthGuard` at least pretend to authenticate.

  我们先让`AuthGuard`至少能“假装”进行认证。

  The `AuthGuard` should call an application service that can login a user and retain information about the current user.
  Here's a demo `AuthService`:

  `AuthGuard`可以调用应用中的一项服务，该服务能让用户登录，并且保存当前用户的信息。下面是一个`AuthService`的示范：

+makeExcerpt('src/app/auth.service.ts')

:marked
  Although it doesn't actually log in, it has what you need for this discussion.
  It has an `isLoggedIn` flag to tell you whether the user is authenticated.
  Its `login` method simulates an API call to an external service by returning an 
  Observable that resolves successfully after a short pause.
  The `redirectUrl` property will store the attempted URL so you can navigate to it after authenticating.

  虽然它不会真的进行登录，但足够让我们进行这个讨论了。
  它有一个`isLoggedIn`标志，用来标识是否用户已经登录过了。
  它的`login`方法会仿真一个对外部服务的API调用，返回一个可观察对象（observable）。在短暂的停顿之后，这个可观察对象就会解析成功。
  `redirectUrl`属性将会保存在URL中，以便认证完之后导航到它。

  Revise the `AuthGuard` to call it.

  我们这就修改`AuthGuard`来调用它。

+makeExcerpt('src/app/auth-guard.service.2.ts (v2)', '')

:marked
  Notice that you *inject* the `AuthService` and the `Router` in the constructor.
  You haven't provided the `AuthService` yet but it's good to know that you can inject helpful services into routing guards.

  注意，我们把`AuthService`和`Router`服务*注入到*构造函数中。
  我们还没有提供`AuthService`，这里要说明的是：可以往路由守卫中注入有用的服务。

  This guard returns a synchronous boolean result.
  If the user is logged in, it returns true and the navigation continues.

  该守卫返回一个同步的布尔值。如果用户已经登录，它就返回`true`，导航会继续。

  The `ActivatedRouteSnapshot` contains the _future_ route that will be activated and the `RouterStateSnapshot`
  contains the _future_ `RouterState` of the application, should you pass through the guard check.

  这个`ActivatedRouteSnapshot`包含了_即将_被激活的路由，而`RouterStateSnapshot`包含了该应用_即将_到达的状态。
  它们要通过我们的守卫进行检查。

  If the user is not logged in, you store the attempted URL the user came from using the `RouterStateSnapshot.url` and
  tell the router to navigate to a login page&mdash;a page you haven't created yet.
  This secondary navigation automatically cancels the current navigation; `checkLogin()` returns 
  `false` just to be clear about that.

  如果用户还没有登录，我们会用`RouterStateSnapshot.url`保存用户来自的URL并让路由器导航到登录页（我们尚未创建该页）。
  这间接导致路由器自动中止了这次导航，`checkLogin()`返回`false`并不是必须的，但这样可以更清楚的表达意图。

a#add-login-component
:marked
  #### Add the *LoginComponent*
  
  #### 添加*LoginComponent*
  
  You need a `LoginComponent` for the user to log in to the app. After logging in, you'll redirect
    to the stored URL if available, or use the default URL.
    There is nothing new about this component or the way you wire it into the router configuration.
    
    我们需要一个`LoginComponent`来让用户登录进这个应用。在登录之后，我们跳转到前面保存的URL，如果没有，就跳转到默认URL。
      该组件没有什么新内容，我们把它放进路由配置的方式也没什么新意。

  Register a `/login` route in the `login-routing.module.ts` and add the necessary providers to the `providers`
    array. In `app.module.ts`, import the `LoginComponent` and add it to the `AppModule` `declarations`.
    Import and add the `LoginRoutingModule` to the `AppModule` imports as well.

  我们将在`login-routing.module.ts`中注册一个`/login`路由，并把必要的提供商添加`providers`数组中。
  在`app.module.ts`中，我们导入`LoginComponent`并把它加入根模块的`declarations`中。
  同时在`AppModule`中导入并添加`LoginRoutingModule`。

+makeTabs(
   `router/ts/src/app/app.module.ts,
   router/ts/src/app/login.component.1.ts,
   router/ts/src/app/login-routing.module.ts
  `,
  null,
   `src/app/app.module.ts,
   src/app/login.component.ts,
   src/app/login-routing.module.ts
  `)

.l-sub-section
  :marked
    Guards and the service providers they require _must_ be provided at the module-level. This allows
    the Router access to retrieve these services from the `Injector` during the navigation process.
    The same rule applies for feature modules loaded [asynchronously](#asynchronous-routing).
    
    它们所需的守卫和服务提供商**必须**在模块一级提供。这让路由器在导航过程中可以通过`Injector`来取得这些服务。
        同样的规则也适用于[异步加载](#asynchronous-routing)的特性模块。

a#can-activate-child-guard
:marked
  ### _CanActivateChild_: guarding child routes

  You can also protect child routes with the `CanActivateChild` guard. 
  The `CanActivateChild` guard is similar to the `CanActivate` guard.
  The key difference is that it runs _before_  any child route is activated. 

  You protected the admin feature module from unauthorized access. 
  You should also protect child routes _within_ the feature module.

  Extend the `AuthGuard` to protect when navigating between the `admin` routes. 
  Open `auth-guard.service.ts` and add the `CanActivateChild` interface to the imported tokens from the router package.

  Next, implement the `CanActivateChild` method which takes the same arguments as the `CanActivate` method:
  an `ActivatedRouteSnapshot` and `RouterStateSnapshot`. 
  The `CanActivateChild` method can return an `Observable<boolean>` or `Promise<boolean>` for 
  async checks and a `boolean` for sync checks.
  This one returns a `boolean`:

+makeExcerpt('src/app/auth-guard.service.3.ts (excerpt)', 'can-activate-child')

:marked
  Add the same `AuthGuard` to the `component-less` admin route to protect all other child routes at one time
  instead of adding the `AuthGuard` to each route individually.

+makeExcerpt('src/app/admin/admin-routing.module.3.ts (excerpt)', 'can-activate-child')

a#can-deactivate-guard
:marked
  ### _CanDeactivate_: handling unsaved changes
  
  ### *CanDeactivate*：处理未保存的更改
  
  Back in the "Heroes" workflow, the app accepts every change to a hero immediately without hesitation or validation.

  回到“Heroes”工作流，该应用毫不犹豫的接受对英雄的任何修改，不作任何校验。

  In the real world, you might have to accumulate the users changes.
  You might have to validate across fields. 
  You might have to validate on the server.
  You might have to hold changes in a pending state until the user confirms them *as a group* or
  cancels and reverts all changes.

  在现实世界中，我们得先把用户的改动积累起来。
  我们可能不得不进行跨字段的校验，可能要找服务器进行校验，可能得把这些改动保存成一种待定状态，直到用户或者把这些改动*作为一组*进行确认或撤销所有改动。

  What do you do about unapproved, unsaved changes when the user navigates away?
  You can't just leave and risk losing the user's changes; that would be a terrible experience.
  
  当用户要导航到外面时，该怎么处理这些既没有审核通过又没有保存过的改动呢？
    我们不能马上离开，不在乎丢失这些改动的风险，那显然是一种糟糕的用户体验。

  It's better to pause and let the user decide what to do.
  If the user cancels, you'll stay put and allow more changes.
  If the user approves, the app can save.
  
  我们应该暂停，并让用户决定该怎么做。如果用户选择了取消，我们就留下来，并允许更多改动。如果用户选择了确认，那就进行保存。

  You still might delay navigation until the save succeeds.
  If you let the user move to the next screen immediately and
  the save were to fail (perhaps the data are ruled invalid), you would lose the context of the error.
  
  在保存成功之前，我们还可以继续推迟导航。如果我们让用户立即移到下一个界面，而保存却失败了（可能因为数据不符合有效性规则），我们就会丢失该错误的上下文环境。

  You can't block while waiting for the server&mdash;that's not possible in a browser.
  You need to stop the navigation while you wait, asynchronously, for the server
  to return with its answer.
  
  在等待服务器的答复时，我们没法阻塞它 —— 这在浏览器中是不可能的。
    我们只能用异步的方式在等待服务器答复之前先停止导航。

  You need the `CanDeactivate` guard.
  
  我们需要`CanDeactivate`守卫。

a#cancel-save
:marked
  ### Cancel and save

  The sample application doesn't talk to a server.
  Fortunately, you have another way to demonstrate an asynchronous router hook.

  我们的范例应用不会与服务器通讯。
  幸运的是，我们有另一种方式来演示异步的路由器钩子。

  Users update crisis information in the `CrisisDetailComponent`.
  Unlike the `HeroDetailComponent`, the user changes do not update the crisis entity immediately. 
  Instead, the app updates the entity when the user presses the *Save* button and 
  discards the changes when the user presses the *Cancel* button.

  用户在`CrisisDetailComponent`中更新危机信息。
  与`HeroDetailComponent`不同，用户的改动不会立即更新危机的实体对象。当用户按下了*Save*按钮时，我们就更新这个实体对象；如果按了*Cancel*按钮，那就放弃这些更改。

  Both buttons navigate back to the crisis list after save or cancel.

  这两个按钮都会在保存或取消之后导航回危机列表。

+makeExcerpt('src/app/crisis-center/crisis-detail.component.ts (cancel and save methods)', 'cancel-save')

:marked
  What if the user tries to navigate away without saving or canceling?
  The user could push the browser back button or click the heroes link.
  Both actions trigger a navigation.
  Should the app save or cancel automatically?
  
  如果用户尝试不保存或撤销就导航到外面该怎么办？
    用户可以按浏览器的后退按钮，或点击英雄的链接。
    这些操作都会触发导航。本应用应该自动保存或取消吗？

  This demo does neither. Instead, it asks the user to make that choice explicitly
  in a confirmation dialog box that *waits asynchronously for the user's
  answer*.

  都不行。我们应该弹出一个确认对话框来要求用户明确做出选择，该对话框会*用异步的方式等用户做出选择*。

.l-sub-section

  :marked
    You could wait for the user's answer with synchronous, blocking code.
    The app will be more responsive&mdash;and can do other work&mdash;by 
    waiting for the user's answer asynchronously. Waiting for the user asynchronously
    is like waiting for the server asynchronously.

    我们也能用同步的方式等用户的答复，阻塞代码。但如果能用异步的方式等待用户的答复，应用就会响应性更好，也能同时做别的事。异步等待用户的答复和等待服务器的答复是类似的。

:marked
  The `DialogService`, provided in the `AppModule` for app-wide use, does the asking.

  `DialogService`（为了在应用级使用，已经注入到了`AppModule`）就可以做到这些。

  It returns a [promise](http://exploringjs.com/es6/ch_promises.html) that
  *resolves* when the user eventually decides what to do: either
  to discard changes and navigate away (`true`) or to preserve the pending changes and stay in the crisis editor (`false`).

  它返回[promise](http://exploringjs.com/es6/ch_promises.html)，当用户最终决定了如何去做时，它就会被*解析* —— 或者决定放弃更改直接导航离开（`true`），或者保留未完成的修改，留在危机编辑器中（`false`）。

a#CanDeactivate
:marked
  Create a _guard_ that checks for the presence of a `canDeactivate` method in a component&mdash;any component.
  The `CrisisDetailComponent` will have this method. 
  But the guard doesn't have to know that. 
  The guard shouldn't know the details of any component's deactivation method.
  It need only detect that the component has a `canDeactivate()` method and call it.
  This approach makes the guard reusable.

  我们创建了一个`Guard`，它将检查这个组件中`canDeactivate`函数的工作现场，在这里，它就是`CrisisDetailComponent`。我们并不需要知道`CrisisDetailComponent`确认退出激活状态的详情。这让我们的守卫可以被复用，这是一次轻而易举的胜利。

+makeExample('src/app/can-deactivate-guard.service.ts')

:marked
  Alternatively, you could make a component-specific `CanDeactivate` guard for the `CrisisDetailComponent`. 
  The `canDeactivate()` method provides you with the current 
  instance of the `component`, the current `ActivatedRoute`, 
  and `RouterStateSnapshot` in case you needed to access
  some external information. This would be useful if you only 
  wanted to use this guard for this component and needed to get 
  the component's properties or confirm whether the router should allow navigation away from it.

  另外，我们也可以为`CrisisDetailComponent`创建一个特定的`CanDeactivate`守卫。在需要访问外部信息时，`canDeactivate()`方法为提供了组件、`ActivatedRoute`和`RouterStateSnapshot`的当前实例。如果只想为这个组件使用该守卫，并且需要使用该组件属性、或者需要路由器确认是否允许从该组件导航出去时，这个守卫就非常有用。

+makeExcerpt('src/app/can-deactivate-guard.service.1.ts (component-specific)', '')

:marked
  Looking back at the `CrisisDetailComponent`, it implements the confirmation workflow for unsaved changes.

  看看`CrisisDetailComponent`组件，我们已经实现了对未保存的更改进行确认的工作流。

+makeExcerpt('src/app/crisis-center/crisis-detail.component.ts (excerpt)', 'canDeactivate')

:marked
  Notice that the `canDeactivate` method *can* return synchronously;
  it returns `true` immediately if there is no crisis or there are no pending changes.
  But it can also return a `Promise` or an `Observable` and the router will wait for that
  to resolve to truthy (navigate) or falsy (stay put).

  注意，`canDeactivate`方法*可以*同步返回，如果没有危机，或者没有未定的修改，它就立即返回`true`。但是它也可以返回一个承诺（`Promise`）或可观察对象（`Observable`），路由器将等待它们被解析为真值（继续导航）或假值（留下）。

:marked
  Add the `Guard` to the crisis detail route in `crisis-center-routing.module.ts` using the `canDeactivate` array.

  我们往`crisis-center.routing.ts`的危机详情路由中用`canDeactivate`数组添加一个`Guard`（守卫）。

+makeExcerpt('src/app/crisis-center/crisis-center-routing.module.3.ts (can deactivate guard)', '')

:marked
  Add the `Guard` to the main `AppRoutingModule` `providers` array so the 
  `Router` can inject it during the navigation process.

  我们还要把这个`Guard`添加到`appRoutingModule`的`providers`中去，以便`Router`可以在导航过程中注入它。

+makeExample('src/app/app-routing.module.4.ts', '', '')

:marked
  Now you have given the user a safeguard against unsaved changes.

  现在，我们已经给了用户一个能保护未保存更改的安全守卫。

<a id="Resolve"></a>
a#resolve-guard 
:marked
  ### _Resolve_: pre-fetching component data
  
  ### _Resolve_: 预先获取组件数据

  In the `Hero Detail` and `Crisis Detail`, the app waited until the route was activated to fetch the respective hero or crisis.
  
  在`Hero Detail`和`Crisis Detail`中，它们等待路由读取完对应的英雄和危机。

  This worked well, but there's a better way.
  If you were using a real world API, there might be some delay before the data to display is returned from the server.
  You don't want to display a blank component while waiting for the data.
  
  这种方式没有问题，但是它们还有进步的空间。
    如果我们在使用真实api，很有可能数据返回有延迟，导致无法即时显示。
    在这种情况下，直到数据到达前，显示一个空的组件不是最好的用户体验。

  It's preferable to pre-fetch data from the server so it's ready the 
  moment the route is activated. This also allows you to handle errors before routing to the component.
  There's no point in navigating to a crisis detail for an `id` that doesn't have a record.
  It'd be better to send the user back to the `Crisis List` that shows only valid crisis centers.
  
  我们最好预先从服务器上获取完数据，这样在路由激活的那一刻数据就准备好了。
  还要在路由到此组件之前处理好错误。
  但当某个`id`无法对应到一个危机详情时，我们没办法处理它。
  这时我们最好把用户带回到“危机列表”中，那里显示了所有有效的“危机”。

  In summary, you want to delay rendering the routed component until all necessary data have been fetched.
  
  总之，你希望的是只有当所有必要数据都已经拿到之后，才渲染这个路由组件。

  You need a *resolver*.

  我们需要`Resolve`守卫。

a#fetch-before-navigating 
:marked
  ### Fetch data before navigating
  
  ### 导航前预先加载路由信息

  At the moment, the `CrisisDetailComponent` retrieves the selected crisis.
  If the crisis is not found, it navigates back to the crisis list view. 

  The experience might be better if all of this were handled first, before the route is activated.
  A `CrisisDetailResolver` service could retrieve a `Crisis` or navigate away if the `Crisis` does not exist
  _before_ activating the route and creating the `CrisisDetailComponent`.

  Create the `crisis-detail-resolver.service.ts` file within the `Crisis Center` feature area.

+makeExample('src/app/crisis-center/crisis-detail-resolver.service.ts', '')

:marked
  Take the relevant parts of the crisis retrieval logic in `CrisisDetailComponent.ngOnInit` 
  and move them into the `CrisisDetailResolver`.
  Import the `Crisis` model, `CrisisService`, and the `Router` 
  so you can navigate elsewhere if you can't fetch the crisis. 
  
  Be explicit. Implement the `Resolve` interface with a type of `Crisis`. 
  
  Inject the `CrisisService` and `Router` and implement the `resolve()` method.
  That method could return a `Promise`, an `Observable`, or a synchronous return value.

  The `CrisisService.getCrisis` method returns a promise. 
  Return that promise to prevent the route from loading until the data is fetched. 
  If it doesn't return a valid `Crisis`, navigate the user back to the `CrisisListComponent`, 
  canceling the previous in-flight navigation to the `CrisisDetailComponent`.

  Import this resolver in the `crisis-center-routing.module.ts` 
  and add a `resolve` object to the `CrisisDetailComponent` route configuration.

  Remember to add the `CrisisDetailResolver` service to the `CrisisCenterRoutingModule`'s `providers` array.

+makeExcerpt('src/app/crisis-center/crisis-center-routing.module.4.ts (resolver)', 'crisis-detail-resolver')

:marked
  The `CrisisDetailComponent` should no longer fetch the crisis.
  Update the `CrisisDetailComponent` to get the crisis from the  `ActivatedRoute.data.crisis` property instead;
  that's where you said it should be when you re-configured the route.
  It will be there when the `CrisisDetailComponent` ask for it.

+makeExcerpt('src/app/crisis-center/crisis-detail.component.ts (ngOnInit v2)', 'ngOnInit')

:marked
  **Two critical points**
  
  **两个关键点**
  
  1. The router's `Resolve` interface is optional. 
  The `CrisisDetailResolver` doesn't inherit from a base class. 
  The router looks for that method and calls it if found.
  
      路由器的这个`Resolve`接口是可选的。`CrisisDetailResolver`没有继承自某个基类。路由器只要找到了这个方法，就会调用它。

  1. Rely on the router to call the resolver. 
  Don't worry about all the ways that the user  could navigate away. 
  That's the router's job. Write this class and let the router take it from there.
  
      我们依赖路由器调用此守卫。不必关心用户用哪种方式导航离开，这是路由器的工作。我们只要写出这个类，等路由器从那里取出它就可以了。

  The relevant *Crisis Center* code for this milestone follows.

  本里程碑中与*危机中心*有关的代码如下：

+makeTabs(
   `router/ts/src/app/app.component.ts,
   router/ts/src/app/crisis-center/crisis-center-home.component.ts,
   router/ts/src/app/crisis-center/crisis-center.component.ts,
   router/ts/src/app/crisis-center/crisis-center-routing.module.4.ts,
   router/ts/src/app/crisis-center/crisis-list.component.ts,
   router/ts/src/app/crisis-center/crisis-detail.component.ts,
   router/ts/src/app/crisis-center/crisis-detail-resolver.service.ts,
   router/ts/src/app/crisis-center/crisis.service.ts
  `,
  null,
   `app.component.ts,
   crisis-center-home.component.ts,
   crisis-center.component.ts,
   crisis-center-routing.module.ts,
   crisis-list.component.ts,
   crisis-detail.component.ts,
   crisis-detail-resolver.service.ts,
   crisis.service.ts
  `)

+makeTabs(
   `router/ts/src/app/auth-guard.service.3.ts,
   router/ts/src/app/can-deactivate-guard.service.ts
  `,
  null,
   `auth-guard.service.ts,
   can-deactivate-guard.service.ts
  `)

a#query-parameters
a#fragment
:marked
  ### Query parameters and fragments

  ### 查询参数及片段

  In the [route parameters](#optional-route-parameters) example, you only dealt with parameters specific to
  the route, but what if you wanted optional parameters available to all routes? 
  This is where query parameters come into play.

  在这个[查询参数](#query-parameters)例子中，我们只为路由指定了参数，但是该如何定义一些所有路由中都可用的可选参数呢？
  这就该“查询参数”登场了。

  [Fragments](https://en.wikipedia.org/wiki/Fragment_identifier) refer to certain elements on the page
  identified with an `id` attribute.

  [片段](https://en.wikipedia.org/wiki/Fragment_identifier)可以引用页面中带有特定`id`属性的元素.

  Update the `AuthGuard` to provide a `session_id` query that will remain after navigating to another route.
  
  接下来，我们将更新`AuthGuard`来提供`session_id`查询参数，在导航到其它路由后，它还会存在。

  Add an `anchor` element so you can jump to a certain point on the page.
  
  再添加一个锚点（`A`）元素，来让你能跳转到页面中的正确位置。

  Add the `NavigationExtras` object to the `router.navigate` method that navigates you to the `/login` route.
  
  我们还将为`router.nativate`方法传入一个`NavigationExtras`对象，用来导航到`/login`路由。

+makeExcerpt('src/app/auth-guard.service.4.ts (v3)', '')

:marked
  You can also preserve query parameters and fragments across navigations without having to provide them
  again when navigating. In the `LoginComponent`, you'll add an *object* as the 
  second argument in the `router.navigate` function
  and provide the `preserveQueryParams` and `preserveFragment` to pass along the current query parameters
  and fragment to the next route.

  还可以再导航之间**保留**查询参数和片段，而无需再次再导航中提供。在`LoginComponent`中的`router.navigate`方法中，添加第二个参数，该**对象**提供了`preserveQueryParams`和 `preserveFragment`，用于传递到当前的查询参数中并为下一个路由提供片段。

+makeExcerpt('src/app/login.component.ts', 'preserve')

:marked
  Since you'll be navigating to the *Admin Dashboard* route after logging in, you'll update it to handle the
  query parameters and fragment.

  由于要在登录后导航到*危机管理*特征区的路由，所以我们还得更新它，来处理这些全局查询参数和片段。

+makeExcerpt('src/app/admin/admin-dashboard.component.2.ts (v2)', '')

:marked
  *Query Parameters* and *Fragments* are also available through the `ActivatedRoute` service.
  Just like *route parameters*, the query parameters and fragments are provided as an `Observable`.
  The updated *Crisis Admin* component feeds the `Observable` directly into the template using the `AsyncPipe`.
  
  *查询参数*和*片段*可通过`Router`服务的`routerState`属性使用。和*路由参数*类似，全局查询参数和片段也是`Observable`对象。
    在更新过的*英雄管理*组件中，我们将直接把`Observable`传给模板，借助`AsyncPipe`在组件被销毁时自动_取消_对`Observable`的订阅。

include ../../../_includes/_see-addr-bar

:marked
  Now, you can click on the *Admin* button, which takes you to the *Login*
  page with the provided `query params` and `fragment`. After you click the login button, notice that
  you have been redirected to the `Admin Dashboard` page with the `query params` and `fragment` still intact. 
  
  按照下列步骤试验下：点击*Crisis Admin*按钮，它会带着我们提供的“查询参数”和“片段”跳转到登录页。
    点击登录按钮，我们就会被带到`Crisis Admin`页，仍然带着上一步提供的“查询参数”和“片段”。
  
  You can use these persistent bits of information for things that need to be provided across pages like
  authentication tokens or session ids.
  
  我们可以用这些持久化信息来携带需要为每个页面都提供的信息，如认证令牌或会话的ID等。

.l-sub-section
  :marked
    The `query params` and `fragment` can also be preserved using a `RouterLink` with
    the `preserveQueryParams` and `preserveFragment` bindings respectively.
    
    “查询参数”和“片段”也可以分别用`RouterLink`中的**preserveQueryParams**和**preserveFragment**保存。

.l-main-section#asynchronous-routing
:marked
  ## Milestone 6: Asynchronous routing
  
  ## 里程碑6：异步路由

  As you've worked through the milestones, the application has naturally gotten larger. 
  As you continue to build out feature areas, the overall application size will continue to grow. 
  At some point you'll reach a tipping point where the application takes long time to load. 
  
  完成上面的里程碑后，我们的应用程序很自然的长大了。在继续构建特征区的过程中，应用的尺寸将会变得更大。在某一个时间点，我们将达到一个顶点，应用将会需要过多的时间来加载。

  How do you combat this problem?  With asynchronous routing, which loads feature modules _lazily_, on request.
  Lazy loading has multiple benefits.
  
  如何才能解决这个问题呢？我们引进了异步路由到应用程序中，并获得在请求时才**惰性**加载特征模块的能力。这样给我们带来了下列好处：

  * You can load feature areas only when requested by the user.
  
      我们可以只在用户请求时才加载某些特性区。
      
  * You can speed up load time for users that only visit certain areas of the application.
  
      对于那些只访问应用程序某些区域的用户，这样能加快加载速度。
      
  * You can continue expanding lazy loaded feature areas without increasing the size of the initial load bundle.
  
      你可以持续扩充惰性加载特性区的功能，而不用增加初始加载的包体积。

  You're already made part way there.  
  By organizing the application into modules&mdash;`AppModule`, 
  `HeroesModule`, `AdminModule` and `CrisisCenterModule`&mdash;you 
  have natural candidates for lazy loading.

  Some modules, like `AppModule`, must be loaded from the start.
  But others can and should be lazy loaded.
  The `AdminModule`, for example, is needed by a few authorized users, so
  you should only load it when requested by the right people.

a#lazy-loading-route-config
:marked
  ### Lazy Loading route configuration
  
  ### 惰性加载路由配置

  Change the `admin` **path** in the `admin-routing.module.ts` from `'admin'` to an empty string, `''`, the _empty path_. 

  The `Router` supports  *empty path* routes;
  use them to group routes together without adding any additional path segments to the URL. 
  Users will still visit `/admin` and the `AdminComponent` still serves as the *Routing Component* containing child routes.

  Open the `AppRoutingModule` and add a new `admin` route to its `appRoutes` array.

  Give it a `loadChildren` property (not a `children` property!), set to the address of the `AdminModule`.
  The address is the `AdminModule` file location (relative to the app root), 
  followed by a `#` separator, 
  followed by the name of the exported module class, `AdminModule`. 

+makeExample('router/ts/src/app/app-routing.module.5.ts', 'admin-1', 'app-routing.module.ts (load children)')
:marked
  When the router navigates to this route, it uses the `loadChildren` string to dynamically load the `AdminModule`.
  Then it adds the `AdminModule` routes to its current route configuration.
  Finally, it loads the requested route to the destination admin component. 

  The lazy loading and re-configuration happen just once, when the route is _first_ requested;
  the module and routes are available immediately for subsequent requests.

.l-sub-section
  :marked
    Angular provides a built-in module loader that supports SystemJS to load modules asynchronously. If you were
    using another bundling tool, such as Webpack, you would use the Webpack mechanism for asynchronously loading modules.

    Angular提供一个内置模块加载器，支持**`SystemJS`**来异步加载模块。如果我们使用其它捆绑工具比如**Webpack**，则使用Webpack的机制来异步加载模块。

:marked
  Take the final step and detach the admin feature set from the main application.
  The root `AppModule` must neither load nor reference the `AdminModule` or its files.

  In `app.module.ts`, remove the `AdminModule` import statement from the top of the file
  and remove the `AdminModule` from the Angular module's `imports` array.

a#can-load-guard
:marked
  ### _CanLoad_ Guard: guarding unauthorized loading of feature modules

  You're already protecting the `AdminModule` with a `CanActivate` guard that prevents unauthorized users from
  accessing the admin feature area. 
  It redirects to the  login page if the user is not authorized.
  
  我们已经使用`CanAcitvate`保护`AdminModule`了，它会阻止未授权用户访问管理特性区。如果用户未登录，它就会跳转到登录页。
  
  But the router is still loading the `AdminModule` even if the user can't visit any of its components.
  Ideally, you'd only load the `AdminModule` if the user is logged in.

  Add a **`CanLoad`** guard that only loads the `AdminModule` once the user is logged in _and_ attempts to access the admin feature area.

  The existing `AuthGuard` already has the essential logic in 
  its `checkLogin()` method to support the `CanLoad` guard. 
  
  Open `auth-guard.service.ts`.
  Import the `CanLoad` interface from `@angular/router`.
  Add it to the `AuthGuard` class's `implements` list.
  Then implement `canLoad` as follows:

+makeExcerpt('src/app/auth-guard.service.ts (CanLoad guard)', 'canLoad')
:marked
  The router sets the `canLoad()` method's `route` parameter to the intended destination URL.
  The `checkLogin()` method redirects to that URL once the user has logged in.

  Now import the `AuthGuard` into the `AppRoutingModule` and add the `AuthGuard` to the `canLoad` 
  array for the `admin` route. 
  The completed admin route looks like this:

+makeExample('router/ts/src/app/app-routing.module.5.ts', 'admin', 'app-routing.module.ts (lazy admin route)')


a#preloading
:marked
  ### Preloading: background loading of feature areas
  You've learned how to load modules on-demand.
  You can also load modules asynchronously with _preloading_.

  This may seem like what the app has been doing all along. Not quite.
  The `AppModule` is loaded when the application starts; that's _eager_ loading.
  Now the `AdminModule` loads only when the user clicks on a link; that's _lazy_ loading.
  
  _Preloading_ is something in between.
  Consider the _Crisis Center_.
  It isn't the first view that a user sees.  
  By default, the _Heroes_ are the first view.
  For the smallest initial payload and fastest launch time, 
  you should eagerly load the `AppModule` and the `HeroesModule`.

  You could lazy load the _Crisis Center_.
  But you're almost certain that the user will visit the _Crisis Center_ within minutes of launching the app.
  Ideally, the app would launch with just the `AppModule` and the `HeroesModule` loaded
  and then, almost immediately, load the `CrisisCenterModule` in the background.
  By the time the user navigates to the _Crisis Center_, its module will have been loaded and ready to go.

  That's _preloading_.

a#how-preloading
:marked
  #### How preloading works

  After each _successful_ navigation, the router looks in its configuration for an unloaded module that it can preload.
  Whether it preloads a module, and which modules it preloads, depends upon the *preload strategy*.

  The `Router` offers two preloading strategies out of the box:

  * No preloading at all which is the default. Lazy loaded feature areas are still loaded on demand.
  * Preloading of all lazy loaded feature areas.

  Out of the box, the router either never preloads, or preloads every lazy load module.
  The `Router` also supports [custom preloading strategies](#custom-preloading) for 
  fine control over which modules to preload and when.

  In this next section, you'll update the `CrisisCenterModule` to load lazily 
  by default and use the `PreloadAllModules` strategy
  to load it (and _all other_ lazy loaded modules) as soon as possible.

a#lazy-load-crisis-center
:marked
  #### Lazy load the _crisis center_

  Update the route configuration to lazy load the `CrisisCenterModule`. 
  Take the same steps you used to configure `AdminModule` for lazy load.

  1. Change the `crisis-center` path in the `CrisisCenterRoutingModule` to an empty string.

  1. Add a `crisis-center` route to the `AppRoutingModule`.
  
  1. Set the `loadChildren` string to load the `CrisisCenterModule`.

  1. Remove all mention of the `CrisisCenterModule` from `app.module.ts`.

  Here are the updated modules _before enabling preload_:

  下面是打开预加载之前的模块修改版：

+makeTabs(
   `router/ts/src/app/app.module.ts,
    router/ts/src/app/app-routing.module.6.ts,
    router/ts/src/app/crisis-center/crisis-center-routing.module.ts
  `,
  ',preload-v1,',
   `app.module.ts,
    app-routing.module.ts,
    crisis-center-routing.module.ts
  `)
:marked
  You could try this now and confirm that the  `CrisisCenterModule` loads after you click the "Crisis Center" button.

  To enable preloading of all lazy loaded modules, import the `PreloadAllModules` token from the Angular router package.

  The second argument in the `RouterModule.forRoot` method takes an object for additional configuration options.
  The `preloadingStrategy` is one of those options. 
  Add the `PreloadAllModules` token to the `forRoot` call:
  
  `RouterModule.forRoot`方法的第二个参数接受一个附加配置选项对象。
  `preloadingStrategy`就是其中之一。
  把`PreloadAllModules`添加到`forRoot`调用中：
  
+makeExcerpt('src/app/app-routing.module.6.ts (preload all)', 'forRoot')
:marked
  This tells the `Router` preloader to immediately load _all_ lazy loaded routes (routes with a `loadChildren` property).

  When you visit `http://localhost:3000`, the `/heroes` route loads immediately upon launch
  and the router starts loading the `CrisisCenterModule` right after the `HeroesModule` loads.
  
  Surprisingly, the `AdminModule` does _not_ preload. Something is blocking it.

a#preload-canload
:marked
  #### CanLoad blocks preload

  The `PreloadAllModules` strategy does not load feature areas protected by a [CanLoad](#can-load-guard) guard.
  This is by design.
  
  You added a `CanLoad` guard to the route in the `AdminModule` a few steps back
  to block loading of that module until the user is authorized.
  That `CanLoad` guard takes precedence over the preload strategy.
  
  If you want to preload a module _and_ guard against unauthorized access, 
  drop the `canLoad` guard and rely on the [CanActivate](#can-activate-guard) guard alone.

a#custom-preloading
:marked
  ### Custom Preloading Strategy

  Preloading every lazy loaded modules works well in many situations, 
  but it isn't always the right choice, especially on mobile devices and over low bandwidth connections. 
  You may choose to preload only certain feature modules, based on user metrics and other business and technical factors.

  You can control what and how the router preloads with a custom preloading strategy.

  In this section, you'll add a custom strategy that _only_ preloads routes whose `data.preload` flag is set to `true`. 
  Recall that you can add anything to the `data` property of a route. 

  Set the `data.preload` flag in the `crisis-center` route in the `AppRoutingModule`. 

+makeExcerpt('src/app/app-routing.module.ts (route data preload)', 'preload-v2')

:marked
  Add a new file to the project called `selective-preloading-strategy.ts`
  and define a `SelectivePreloadingStrategy` service class as follows:
+makeExcerpt('src/app/selective-preloading-strategy.ts', '')

:marked
  `SelectivePreloadingStrategy` implements the `PreloadingStrategy`, which has one method, `preload`.

  The router calls the `preload` method with two arguments:

  1. The route to consider.
  1. A loader function that can load the routed module asynchronously.

  An implementation of `preload`must return an `Observable`.
  If the route should preload, it returns the observable returned by calling the loader function.
  If the route should _not_ preload, it returns an `Observable` of `null`. 

  In this sample, the  `preload` method loads the route if the route's `data.preload` flag is truthy.

  It also has a side-effect. 
  `SelectivePreloadingStrategy` logs the `path` of a selected route in its public `preloadedModules` array.
  
  Shortly, you'll extend the `AdminDashboardComponent` to inject this service and display its `preloadedModules` array.

  But first, make a few changes to the `AppRoutingModule`.

  1. Import `SelectivePreloadingStrategy` into `AppRoutingModule`.
  1. Replace the `PreloadAllModules` strategy in the call to `forRoot` with this `SelectivePreloadingStrategy`. 
  1. Add the `SelectivePreloadingStrategy` strategy to the `AppRoutingModule` providers array so it can be injected 
  elsewhere in the app.

  Now edit the `AdminDashboardComponent` to display the log of preloaded routes.
 
  1. Import the `SelectivePreloadingStrategy` (it's a service).
  1. Inject it into the dashboard's constructor.
  1. Update the template to display the strategy service's `preloadedModules` array.

  When you're done it looks like this.

+makeExcerpt('src/app/admin/admin-dashboard.component.ts (preloaded modules)', '')

:marked
  Once the application loads the initial route, the `CrisisCenterModule` is preloaded. 
  Verify this by logging in to the `Admin` feature area and noting that the `crisis-center` is listed in the `Preloaded Modules`. 
  It's also logged to the browser's console. 

a#inspect-config
.l-main-section
:marked
  ## Inspect the router's configuration

  You put a lot of effort into configuring the router in several routing module files
  and were careful to list them [in the proper order](#routing-module-order).
  Are routes actually evaluated as you planned? 
  How is the router really configured?
  
  You can inspect the router's current configuration any time by injecting it and
  examining its `config` property. 
  For example, update the `AppModule` as follows and look in the browser console window
  to see the finished route configuration.
+makeExcerpt('src/app/app.module.ts (inspect the router config)', 'inspect-config')

a#final-app
.l-main-section

:marked
  ## Wrap up and final app
  
  ## 总结与最终的应用

  You've covered a lot of ground in this guide and the application is too big to reprint here.
  Please visit the <live-example title="Router Sample in Plunker"></live-example> 
  where you can download the final source code.

  本章中涉及到了很多背景知识，而且本应用程序也太大了，所以没法在这里显示。请访问<live-example title="Router Sample in Plunker">在线例子</live-example>，在那里你可以下载最终的源码。

a#appendices
.l-main-section

:marked
  ## Appendices
  
  ## 附录  
  
  The balance of this guide is a set of appendices that
  elaborate some of the points you covered quickly above.

  本章剩下的部分是一组附录，它详尽阐述了我们曾匆匆带过的一些知识点。

  The appendix material isn't essential. Continued reading is for the curious.

  该附件中的内容不是必须的，感兴趣的人才需要阅读它。

a#link-parameters-array
.l-main-section
:marked
  ## Appendix: link parameters array

  ## 附录：链接参数数组
  
  A link parameters array holds the following ingredients for router navigation:

  链接参数数组保存路由导航时所需的成分：

  * The *path* of the route to the destination component.

    指向目标组件的那个路由的*路径（path）*

  * Required and optional route parameters that go into the route URL.

    必备路由参数和可选路由参数，它们将进入该路由的URL

  You can bind the `RouterLink` directive to such an array like this:

  我们可以把`RouterLink`指令绑定到一个数组，就像这样：

+makeExcerpt('src/app/app.component.3.ts', 'h-anchor', '')

:marked
  You've written a two element array when specifying a route parameter like this:

  在指定路由参数时，我们写过一个双元素的数组，就像这样：

+makeExcerpt('src/app/heroes/hero-list.component.1.ts', 'nav-to-detail', '')

:marked
  You can provide optional route parameters in an object like this:

  我们可以在对象中提供可选的路由参数，就像这样：

+makeExcerpt('src/app/app.component.3.ts', 'cc-query-params', '')

:marked
  These three examples cover the need for an app with one level routing.
  The moment you add a child router, such as the crisis center, you create new link array possibilities.

  这三个例子覆盖了我们在单级路由的应用中所需的一切。在添加一个像*危机中心*一样的子路由时，我们创建新链接数组组合。

  Recall that you specified a default child route for the crisis center so this simple `RouterLink` is fine.

  回忆一下，我们曾为*危机中心*指定过一个默认的子路由，以便能使用这种简单的`RouterLink`。

+makeExcerpt('src/app/app.component.3.ts', 'cc-anchor-w-default', '')

:marked
  Parse it out.
  
  分解一下。

  * The first item in the array identifies the parent route (`/crisis-center`).
  
      数组中的第一个条目标记出了父路由(`/crisis-center`)。
      
  * There are no parameters for this parent route so you're done with it.
  
      这个父路由没有参数，因此这步已经完成了。
  
  * There is no default for the child route so you need to pick one.
  
      没有默认的子路由，因此我们得选取一个。
      
  * You're navigating to the `CrisisListComponent`, whose route path is `/`, but you don't need to explicitly add the slash.
  
     我们决定跳转到`CrisisListComponent`，它的路由路径是'/'，但我们不用显式的添加它。
  
  * Voilà! `['/crisis-center']`.
  
      哇！`['/crisis-center']`。

  Take it a step further. Consider the following router link that 
  navigates from the root of the application down to the *Dragon Crisis*:
  
  在下一步，我们会用到它。这次，我们要构建一个从根组件往下导航到“巨龙危机”时的链接参数数组：

+makeExcerpt('src/app/app.component.3.ts', 'Dragon-anchor', '')

:marked
  * The first item in the array identifies the parent route (`/crisis-center`).
  
      数组中的第一个条目用来标记出父路由('/crisis-center')。
      
  * There are no parameters for this parent route so you're done with it.
  
      这个父路由没有参数，因此这步已经完成了。
      
  * The second item identifies the child route details about a particular crisis (`/:id`).
  
      数组中的第二个条目（'/:id'）用来标记出到指定危机的详情页的子路由。
      
  * The details child route requires an `id` route parameter.
  
      详细的子路由需要一个`id`路由参数。
      
  * You added the `id` of the *Dragon Crisis* as the second item in the array (`1`).
  
      我们把*巨龙危机*的`id`添加为该数组中的第二个条目（`1`）。
      
  * The resulting path is `/crisis-center/1`.
  
      最终生成的路径是`/crisis-center/1`。

:marked
  If you wanted to, you could redefine the `AppComponent` template with *Crisis Center* routes exclusively:

+makeExcerpt('src/app/app.component.3.ts', 'template', '')

:marked
  In sum, you can write applications with one, two or more levels of routing.
  The link parameters array affords the flexibility to represent any routing depth and
  any legal sequence of route paths, (required) router parameters, and (optional) route parameter objects.
  
  总结：我们可以用一级、两级或多级路由来写应用程序。
    链接参数数组提供了用来表示任意深度路由的链接参数数组以及任意合法的路由参数序列、必须的路由器参数以及可选的路由参数对象。

a#browser-url-styles
a#location-strategy
.l-main-section
:marked
  ## Appendix: *LocationStrategy* and browser URL styles

  ## 附录：*LocationStrategy*以及浏览器URL样式

  When the router navigates to a new component view, it updates the browser's location and history
  with a URL for that view.
  This is a strictly local URL. The browser shouldn't send this URL to the server
  and should not reload the page.

  当路由器导航到一个新的组件视图时，它会用该视图的URL来更新浏览器的当前地址以及历史。
  严格来说，这个URL其实是本地的，浏览器不会把该URL发给服务器，并且不会重新加载此页面。

  Modern HTML5 browsers support
  <a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries" target="_blank" title="HTML5 browser history push-state">history.pushState</a>,
  a technique that changes a browser's location and history without triggering a server page request.
  The router can compose a "natural" URL that is indistinguishable from
  one that would otherwise require a page load.

  现代HTML 5浏览器支持[history.pushState](https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries) API，
  这是一项可以改变浏览器的当前地址和历史，却又不会触发服务端页面请求的技术。
  路由器可以合成出一个“自然的”URL，它看起来和那些需要进行页面加载的URL没什么区别。

  Here's the *Crisis Center* URL in this "HTML5 pushState" style:
  
  下面是*危机中心*的URL在“HTML 5 pushState”风格下的样子：

code-example(format="nocode").
  localhost:3002/crisis-center/

:marked
  Older browsers send page requests to the server when the location URL changes
  _unless_ the change occurs after a "#" (called the "hash").
  Routers can take advantage of this exception by composing in-application route
  URLs with hashes.  Here's a "hash URL" that routes to the *Crisis Center*.
  
  老旧的浏览器在当前地址的URL变化时总会往服务器发送页面请求……唯一的例外规则是：当这些变化位于“#”（被称为“hash”）后面时不会发送。通过把应用内的路由URL拼接在`#`之后，路由器可以获得这条“例外规则”带来的优点。下面是到*危机中心*路由的“hash URL”：
  
code-example(format="nocode").
  localhost:3002/src/#/crisis-center/

:marked
  The router supports both styles with two `LocationStrategy` providers:
  
  路由器通过两种`LocationStrategy`提供商来支持所有这些风格：
  
  1. `PathLocationStrategy`&mdash;the default "HTML5 pushState" style.

      `PathLocationStrategy` - 默认的策略，支持“HTML 5 pushState”风格。

  1. `HashLocationStrategy`&mdash;the "hash URL" style.

      `HashLocationStrategy` - 支持“hash URL”风格。

  The `RouterModule.forRoot` function sets the `LocationStrategy` to the `PathLocationStrategy`,
  making it the default strategy.
  You can switch to the `HashLocationStrategy` with an override during the bootstrapping process if you prefer it.
  
  `RouterModule.forRoot`函数把`LocationStrategy`设置成了`PathLocationStrategy`，使其成为了默认策略。
  我们可以在启动过程中改写（override）它，来切换到`HashLocationStrategy`风格 —— 如果我们更喜欢这种。
  
.l-sub-section

  :marked
    Learn about providers and the bootstrap process in the
    [Dependency Injection guide](dependency-injection.html#bootstrap).
    
    要学习关于“提供商”和启动过程的更多知识，参见[依赖注入](dependency-injection.html#bootstrap)一章。
    
:marked
  ### Which strategy is best?

  ### 哪种策略更好？

  You must choose a strategy and you need to make the right call early in the project.
  It won't be easy to change later once the application is in production
  and there are lots of application URL references in the wild.

  我们必须选择一种策略，并且在项目的早期就这么干。一旦该应用进入了生产阶段，要改起来可就不容易了，因为外面已经有了大量对应用URL的引用。

  Almost all Angular projects should use the default HTML5 style.
  It produces URLs that are easier for users to understand.
  And it preserves the option to do _server-side rendering_ later.

  几乎所有的Angular项目都会使用默认的HTML 5风格。它生成的URL更易于被用户理解，它也为将来做**服务端渲染**预留了空间。

  Rendering critical pages on the server is a technique that can greatly improve
  perceived responsiveness when the app first loads.
  An app that would otherwise take ten or more seconds to start
  could be rendered on the server and delivered to the user's device
  in less than a second.

  在服务器端渲染指定的页面，是一项可以在该应用首次加载时大幅提升响应速度的技术。那些原本需要十秒甚至更长时间加载的应用，可以预先在服务端渲染好，并在少于一秒的时间内完整呈现在用户的设备上。

  This option is only available if application URLs look like normal web URLs
  without hashes (#) in the middle.

  只有当应用的URL看起来像是标准的Web URL，中间没有hash（#）时，这个选项才能生效。

  Stick with the default unless you have a compelling reason to
  resort to hash routes.

  除非你有强烈的理由不得不使用hash路由，否则就应该坚决使用默认的HTML 5路由风格。

  ### HTML5 URLs and the  *&lt;base href>*
  
  ### HTML 5 URL与*&lt;base href>*  
  
  While the router uses the <a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries" target="_blank" title="Browser history push-state">HTML5 pushState</a>
  style by default, you *must* configure that strategy with a **base href**.

  由于路由器默认使用“<a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries" target="_blank" title="Browser history push-state">HTML 5 pushState</a>”风格，所以我们*必须*用一个**base href**来配置该策略（Strategy）。

  The preferred way to configure the strategy is to add a
  <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base" target="_blank" title="base href">&lt;base href&gt; element</a>
  tag in the `<head>` of the `index.html`.

  配置该策略的首选方式是往`index.html`的`<head>`中添加一个[&lt;base href> element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base)标签。

+makeExcerpt('src/index.html', 'base-href', '')

:marked
  Without that tag, the browser may not be able to load resources
  (images, CSS, scripts) when "deep linking" into the app.
  Bad things could happen when someone pastes an application link into the
  browser's address bar or clicks such a link in an email.

  如果没有此标签，当通过“深链接”进入该应用时，浏览器就不能加载资源（图片、CSS、脚本）。如果有人把应用的链接粘贴进浏览器的地址栏或从邮件中点击应用的链接时，这种问题就发生。

  Some developers may not be able to add the `<base>` element, perhaps because they don't have
  access to `<head>` or the `index.html`.

  有些开发人员可能无法添加`<base>`元素，这可能是因为它们没有访问`<head>`或`index.html`的权限。

  Those developers may still use HTML5 URLs by taking two remedial steps:

  它们仍然可以使用HTML 5格式的URL，但要采取两个步骤进行补救：

  1. Provide the router with an appropriate [APP_BASE_HREF][] value.

      用适当的[APP_BASE_HREF][]值提供（provide）路由器。

  1. Use _root URLs_ for all web resources: CSS, images, scripts, and template HTML files.
  
      对所有Web资源使用**绝对地址**：CSS、图片、脚本、模板HTML。

  [APP_BASE_HREF]: ../api/common/index/APP_BASE_HREF-let.html
  
  [APP_BASE_HREF]: ../api/common/index/APP_BASE_HREF-let.html

:marked
  ### *HashLocationStrategy*

  ### *HashLocationStrategy*

  You can go old-school with the `HashLocationStrategy` by
  providing the `useHash: true` in an object as the second argument of the `RouterModule.forRoot`
  in the `AppModule`.

  我们可以在根模块的`RouterModule.forRoot`的第二个参数中传入一个带有`useHash: true`的对象，以回到基于`HashLocationStrategy`的传统方式。

+makeExcerpt('src/app/app.module.6.ts (hash URL strategy)', '')
